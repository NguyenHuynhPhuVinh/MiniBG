/* eslint-disable @typescript-eslint/no-explicit-any */
import api from "./client";
import {
  MyAvatarDataResponse,
  AvailableItemsResponse,
  EquipItemRequest,
  EquipItemResponse,
  CollectionProgressResponse,
  UserCustomization,
  UserInventory,
  CollectionProgress,
  AvatarData,
  AvatarFrame,
  EmojiData,
  AvatarRarity,
  ItemType,
} from "../../types/avatar";

// Constants for better maintainability
const AVATAR_ENDPOINTS = {
  MY_DATA: "/avatar/my-data",
  AVAILABLE_ITEMS: "/avatar/available-items",
  EQUIP: "/avatar/equip",
  UNEQUIP_FRAME: "/avatar/unequip-frame",
  COLLECTION_PROGRESS: "/avatar/collection-progress",
} as const;

const VALID_ITEM_TYPES: ItemType[] = [
  "avatar",
  "frame",
  "name_effect",
  "emoji",
];

const RARITY_COLORS: Record<AvatarRarity, string> = {
  COMMON: "#9CA3AF", // Gray
  UNCOMMON: "#10B981", // Green
  RARE: "#3B82F6", // Blue
  EPIC: "#8B5CF6", // Purple
  LEGENDARY: "#F59E0B", // Gold
};

const RARITY_DISPLAY_NAMES: Record<AvatarRarity, string> = {
  COMMON: "Th√¥ng th∆∞·ªùng",
  UNCOMMON: "Kh√¥ng ph·ªï bi·∫øn",
  RARE: "Hi·∫øm",
  EPIC: "S·ª≠ thi",
  LEGENDARY: "Huy·ªÅn tho·∫°i",
};

class AvatarService {
  /**
   * L·∫•y d·ªØ li·ªáu avatar ho√†n ch·ªânh c·ªßa user hi·ªán t·∫°i
   * GET /api/avatar/my-data
   */
  async getMyAvatarData(): Promise<MyAvatarDataResponse["data"]> {
    try {
      console.log("üöÄ [Avatar Service] Calling API:", AVATAR_ENDPOINTS.MY_DATA);
      const response = await api.get(AVATAR_ENDPOINTS.MY_DATA);
      console.log("üì° [Avatar Service] Raw API Response:", response);
      const data: MyAvatarDataResponse = response.data;
      console.log("üì¶ [Avatar Service] Parsed Response Data:", data);

      if (!data.success) {
        throw new Error(data.message || "Failed to fetch avatar data");
      }

      console.log("‚úÖ [Avatar Service] Returning data:", data.data);
      return data.data;
    } catch (error: any) {
      console.error(
        "‚ùå [Avatar Service] Error fetching my avatar data:",
        error
      );
      console.error(
        "‚ùå [Avatar Service] Error response:",
        error.response?.data
      );
      throw new Error(
        error.response?.data?.message ||
          error.message ||
          "Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu avatar"
      );
    }
  }

  /**
   * L·∫•y danh s√°ch items c√≥ th·ªÉ m·ªü kh√≥a
   * GET /api/avatar/available-items
   */
  async getAvailableItems(): Promise<AvailableItemsResponse["data"]> {
    try {
      console.log(
        "üöÄ [Avatar Service] Calling API:",
        AVATAR_ENDPOINTS.AVAILABLE_ITEMS
      );
      const response = await api.get(AVATAR_ENDPOINTS.AVAILABLE_ITEMS);
      console.log("üì° [Avatar Service] Raw API Response:", response);
      const data: AvailableItemsResponse = response.data;
      console.log("üì¶ [Avatar Service] Parsed Response Data:", data);

      if (!data.success) {
        throw new Error(data.message || "Failed to fetch available items");
      }

      console.log("‚úÖ [Avatar Service] Returning data:", data.data);
      return data.data;
    } catch (error: any) {
      console.error(
        "‚ùå [Avatar Service] Error fetching available items:",
        error
      );
      console.error(
        "‚ùå [Avatar Service] Error response:",
        error.response?.data
      );
      throw new Error(
        error.response?.data?.message ||
          error.message ||
          "Kh√¥ng th·ªÉ t·∫£i danh s√°ch items"
      );
    }
  }

  /**
   * L·∫•y danh s√°ch items v·ªõi c·∫•u tr√∫c API m·ªõi (tr·ª±c ti·∫øp t·ª´ API response)
   * GET /api/avatar/available-items
   * S·ª≠ d·ª•ng method n√†y thay v√¨ getAvailableItems() cho API m·ªõi
   */
  async getAvailableItemsNew(): Promise<{
    user_level: number;
    user_tier: string;
    avatars: {
      owned: AvatarData[];
      unlockable: AvatarData[];
      locked: AvatarData[];
    };
    frames: {
      owned: AvatarFrame[];
      unlockable: AvatarFrame[];
      locked: AvatarFrame[];
      shop: AvatarFrame[];
    };
    name_effects: {
      owned: any[];
      unlockable: any[];
      locked: any[];
    };
    emojis: {
      owned: EmojiData[];
      unlockable: EmojiData[];
      locked: EmojiData[];
    };
  }> {
    try {
      console.log(
        "üöÄ [Avatar Service] Calling new API structure:",
        AVATAR_ENDPOINTS.AVAILABLE_ITEMS
      );
      const response = await api.get(AVATAR_ENDPOINTS.AVAILABLE_ITEMS);
      console.log("üì° [Avatar Service] Raw API Response (New):", response.data);

      // API m·ªõi tr·∫£ v·ªÅ tr·ª±c ti·∫øp data structure, kh√¥ng c·∫ßn chu·∫©n h√≥a
      const data = response.data.data;
      console.log("‚úÖ [Avatar Service] Returning new structure:", data);
      return data;
    } catch (error: any) {
      console.error(
        "‚ùå [Avatar Service] Error fetching available items (new):",
        error
      );
      console.error(
        "‚ùå [Avatar Service] Error response:",
        error.response?.data
      );
      throw new Error(
        error.response?.data?.message ||
          error.message ||
          "Kh√¥ng th·ªÉ t·∫£i danh s√°ch items"
      );
    }
  }

  /**
   * Trang b·ªã item cho user
   * POST /api/avatar/equip
   */
  async equipItem(request: EquipItemRequest): Promise<UserCustomization> {
    try {
      // Validate request
      this.validateEquipRequest(request);

      const response = await api.post(AVATAR_ENDPOINTS.EQUIP, request);
      const data: EquipItemResponse = response.data;

      if (!data.success) {
        throw new Error(data.message || "Failed to equip item");
      }

      return data.data.customization;
    } catch (error: any) {
      console.error("Error equipping item:", error);
      throw new Error(
        error.response?.data?.message ||
          error.message ||
          "Kh√¥ng th·ªÉ trang b·ªã item"
      );
    }
  }

  /**
   * B·ªè trang b·ªã frame (ch·ªâ √°p d·ª•ng cho frame)
   * POST /api/avatar/unequip-frame
   */
  async unequipFrame(): Promise<UserCustomization> {
    try {
      const response = await api.post(AVATAR_ENDPOINTS.UNEQUIP_FRAME);
      const data: EquipItemResponse = response.data;

      if (!data.success) {
        throw new Error(data.message || "Failed to unequip frame");
      }

      return data.data.customization;
    } catch (error: any) {
      console.error("Error unequipping frame:", error);
      throw new Error(
        error.response?.data?.message ||
          error.message ||
          "Kh√¥ng th·ªÉ b·ªè trang b·ªã frame"
      );
    }
  }

  /**
   * Private method: Validate equip item request
   */
  private validateEquipRequest(request: EquipItemRequest): void {
    if (!request.itemType || !request.itemId) {
      throw new Error("Item type v√† item ID l√† b·∫Øt bu·ªôc");
    }

    if (!VALID_ITEM_TYPES.includes(request.itemType)) {
      throw new Error(
        `Item type kh√¥ng h·ª£p l·ªá. Ch·ªâ ch·∫•p nh·∫≠n: ${VALID_ITEM_TYPES.join(", ")}`
      );
    }

    if (request.itemId <= 0) {
      throw new Error("Item ID ph·∫£i l√† s·ªë d∆∞∆°ng");
    }
  }

  /**
   * L·∫•y ti·∫øn ƒë·ªô s∆∞u t·∫≠p c·ªßa user
   * GET /api/avatar/collection-progress
   */
  async getCollectionProgress(): Promise<CollectionProgress> {
    try {
      const response = await api.get(AVATAR_ENDPOINTS.COLLECTION_PROGRESS);
      const data: CollectionProgressResponse = response.data;

      if (!data.success) {
        throw new Error(data.message || "Failed to fetch collection progress");
      }

      return data.data;
    } catch (error: any) {
      console.error("Error fetching collection progress:", error);
      throw new Error(
        error.response?.data?.message ||
          error.message ||
          "Kh√¥ng th·ªÉ t·∫£i ti·∫øn ƒë·ªô s∆∞u t·∫≠p"
      );
    }
  }

  /**
   * Utility method: L·∫•y avatar hi·ªán t·∫°i ƒëang trang b·ªã t·ª´ inventory
   */
  getEquippedAvatar(
    customization: UserCustomization,
    inventory: UserInventory
  ): AvatarData | null {
    if (!customization.equipped_avatar_id) return null;

    const avatarItem = inventory.avatars.find(
      (item) => item.Avatar.avatar_id === customization.equipped_avatar_id
    );

    return avatarItem?.Avatar || null;
  }

  /**
   * Utility method: L·∫•y frame hi·ªán t·∫°i ƒëang trang b·ªã t·ª´ inventory
   */
  getEquippedFrame(
    customization: UserCustomization,
    inventory: UserInventory
  ): AvatarFrame | null {
    // N·∫øu equipped_frame_id l√† 0 ho·∫∑c null, kh√¥ng c√≥ frame n√†o ƒë∆∞·ª£c trang b·ªã
    if (
      !customization.equipped_frame_id ||
      customization.equipped_frame_id === 0
    ) {
      return null;
    }

    const frameItem = inventory.frames.find(
      (item) => item.Frame.frame_id === customization.equipped_frame_id
    );

    return frameItem?.Frame || null;
  }

  /**
   * Utility method: Ki·ªÉm tra user c√≥ s·ªü h·ªØu item kh√¥ng
   */
  hasItem(
    itemType: "avatar" | "frame" | "emoji",
    itemId: number,
    inventory: UserInventory
  ): boolean {
    switch (itemType) {
      case "avatar":
        return inventory.avatars.some(
          (item) => item.Avatar.avatar_id === itemId
        );
      case "frame":
        return inventory.frames.some((item) => item.Frame.frame_id === itemId);
      case "emoji":
        return inventory.emojis.some((item) => item.Emoji.emoji_id === itemId);
      default:
        return false;
    }
  }

  /**
   * Utility method: Format completion rate
   */
  formatCompletionRate(rate: string): string {
    try {
      const numRate = parseFloat(rate);
      if (isNaN(numRate)) return "0%";
      return `${Math.round(numRate)}%`;
    } catch {
      return "0%";
    }
  }

  /**
   * Utility method: L·∫•y m√†u s·∫Øc theo rarity
   */
  getRarityColor(rarity: string): string {
    return RARITY_COLORS[rarity as AvatarRarity] || RARITY_COLORS.COMMON;
  }

  /**
   * Utility method: L·∫•y t√™n hi·ªÉn th·ªã cho rarity
   */
  getRarityDisplayName(rarity: string): string {
    return RARITY_DISPLAY_NAMES[rarity as AvatarRarity] || "Kh√¥ng x√°c ƒë·ªãnh";
  }

  /**
   * Utility method: Ki·ªÉm tra rarity c√≥ h·ª£p l·ªá kh√¥ng
   */
  isValidRarity(rarity: string): rarity is AvatarRarity {
    return Object.keys(RARITY_COLORS).includes(rarity);
  }

  /**
   * Utility method: L·∫•y t·∫•t c·∫£ rarities c√≥ s·∫µn
   */
  getAllRarities(): AvatarRarity[] {
    return Object.keys(RARITY_COLORS) as AvatarRarity[];
  }
}

export const avatarService = new AvatarService();
export default avatarService;
