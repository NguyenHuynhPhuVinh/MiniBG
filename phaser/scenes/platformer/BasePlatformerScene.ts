import { BaseGameScene } from "../BaseGameScene";
import { EventBus } from "../../EventBus";
import {
  Player,
  InputManager,
  CameraManager,
  TimerManager,
  MinigameCore,
  CHARACTERS,
  NetworkManager,
  AnimationManager,
  AnimationState,
  MobileUIHandler,
} from "../../classes";
import { CAMERA_CONFIG, TIMER_CONFIG } from "../../config/constants";
import { PlatformerLogicCore } from "./PlatformerLogicCore";
import { PlatformerWorldBuilder } from "./PlatformerWorldBuilder";
import { PlatformerPlayerHandler } from "./PlatformerPlayerHandler";
import { PlatformerNetworkHandler } from "../../classes/platformer/PlatformerNetworkHandler";
import { IPlatformerRules } from "./rules/IPlatformerRules";
import { Room } from "colyseus.js";
import {
  GameRoomState,
  Player as PlayerStateSchema,
} from "../../classes/core/types/GameRoomState";
import { IEnvironmentalEffect } from "../../classes/platformer/effects";

/**
 * üéÆ BASE PLATFORMER SCENE - C·∫•p 2: L·ªõp c∆° s·ªü cho d·∫°ng ch∆°i Platformer
 *
 * KI·∫æN TR√öC M·ªöI v·ªõi STRATEGY PATTERN:
 * - Kh√¥ng c√≤n ch·ª©a logic nghi·ªáp v·ª• trong c√°c hook methods
 * - Bu·ªôc subclass ph·∫£i ch·ªçn m·ªôt "b·ªô quy t·∫Øc" (IPlatformerRules)
 * - T√°ch bi·ªát ho√†n to√†n "khung platformer" v√† "lu·∫≠t ch∆°i"
 *
 * TR√ÅCH NHI·ªÜM:
 * - T·∫°o Player v·ªõi v·∫≠t l√Ω platformer
 * - Kh·ªüi t·∫°o InputManager, CameraManager (common cho t·∫•t c·∫£ platformer)
 * - X·ª≠ l√Ω logic chung: t·∫°o map t·ª´ Tiled, setup collision v·ªõi Platforms
 * - Qu·∫£n l√Ω TimerManager cho gameplay
 * - ·ª¶y quy·ªÅn logic nghi·ªáp v·ª• cho IPlatformerRules
 *
 * KI·∫æN TR√öC:
 * - Template Method pattern: Cung c·∫•p skeleton cho platformer
 * - Strategy Pattern: S·ª≠ d·ª•ng IPlatformerRules cho logic nghi·ªáp v·ª•
 * - Composition: S·ª≠ d·ª•ng PlatformerLogicCore v·ªõi rules
 * - Abstract: Subclass ph·∫£i cung c·∫•p config c·ª• th·ªÉ V√Ä rules
 */
export abstract class BasePlatformerScene extends BaseGameScene {
  // === SCENE CONFIGURATION - Subclass ph·∫£i override ===
  protected abstract readonly TILEMAP_KEY: string; // Key c·ªßa tilemap JSON
  protected abstract readonly TILEMAP_PATH: string; // ƒê∆∞·ªùng d·∫´n file JSON
  protected abstract readonly SCENE_NAME: string; // T√™n hi·ªÉn th·ªã scene

  // === STRATEGY PATTERN - Subclass ph·∫£i implement ===
  /**
   * Ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng bu·ªôc scene con ph·∫£i "ch·ªçn" m·ªôt b·ªô lu·∫≠t ch∆°i.
   * ƒê√¢y l√† c·ªët l√µi c·ªßa Strategy Pattern.
   * @returns M·ªôt instance c·ªßa l·ªõp implement IPlatformerRules.
   */
  protected abstract createRules(): IPlatformerRules;

  // === COMPONENTS ===
  protected tilemap!: Phaser.Tilemaps.Tilemap; // B·∫£n ƒë·ªì game t·ª´ Tiled
  protected platformsLayer!: Phaser.Tilemaps.TilemapLayer; // Layer ch·ª©a platforms v√† xu
  protected foregroundLayer?: Phaser.Tilemaps.TilemapLayer; // Layer foreground (t√πy ch·ªçn)

  // === GAME OBJECTS ===
  protected player!: Player; // Nh√¢n v·∫≠t ch√≠nh

  // === MANAGERS ===
  protected inputManager!: InputManager; // Qu·∫£n l√Ω input keyboard
  protected cameraManager!: CameraManager; // Qu·∫£n l√Ω camera effects
  protected timerManager!: TimerManager; // Qu·∫£n l√Ω th·ªùi gian game

  // === MOBILE SUPPORT ===
  private mobileUIHandler?: MobileUIHandler; // UI ƒëi·ªÅu khi·ªÉn tr√™n di ƒë·ªông
  private isMobile: boolean = false; // C·ªù ph√°t hi·ªán thi·∫øt b·ªã di ƒë·ªông
  private mobileTouchCleanupFns: Array<() => void> = [];

  // === MULTIPLAYER ===
  protected networkManager!: NetworkManager; // Qu·∫£n l√Ω k·∫øt n·ªëi m·∫°ng
  protected room?: Room<GameRoomState>; // Ph√≤ng game Colyseus

  // Thay th·∫ø c√°c thu·ªôc t√≠nh multiplayer c≈© b·∫±ng m·ªôt chuy√™n gia duy nh·∫•t
  protected networkHandler!: PlatformerNetworkHandler;

  // TH√äM M·ªöI: M·ªôt thu·ªôc t√≠nh ƒë·ªÉ l∆∞u tr·ªØ h√†m x·ª≠ l√Ω s·ª± ki·ªán
  private networkConnectedHandler!: (room: Room<GameRoomState>) => void;

  // TH√äM M·ªöI: Map ƒë·ªÉ l∆∞u tr·ªØ c√°c tile g·ªëc, gi√∫p ch√∫ng ta t√¨m l·∫°i ch√∫ng d·ªÖ d√†ng
  private originalTiles: Map<string, Phaser.Tilemaps.Tile> = new Map();
  // TH√äM M·ªöI: C·ªù ƒë·ªÉ ƒë·∫£m b·∫£o vi·ªác ƒëƒÉng k√Ω ch·ªâ x·∫£y ra m·ªôt l·∫ßn
  private hasRegisteredBlocks: boolean = false;
  // TH√äM M·ªöI: Map ƒë·ªÉ theo d√µi state cu·ªëi c√πng c·ªßa m·ªói block
  private lastBlockStates: Map<string, string> = new Map();

  // TH√äM M·ªöI: Map ƒë·ªÉ l∆∞u tr·ªØ c√°c sprite t∆∞∆°ng t√°c ƒë∆∞·ª£c t·∫°o b·ªüi WorldBuilder
  private interactiveTileSprites: Map<string, Phaser.GameObjects.Sprite> =
    new Map();

  // ======================== TH√äM C√ÅC H·∫∞NG S·ªê CHO H·ªÜ TH·ªêNG TRUY·ªÄN L·ª∞C ƒê·∫®Y ========================
  private readonly IMPACT_VELOCITY_THRESHOLD = 500; // V·∫≠n t·ªëc t·ªëi thi·ªÉu ƒë·ªÉ g√¢y ra va ch·∫°m (pixels/gi√¢y)
  private readonly IMPACT_RECOIL_FACTOR = -0.4; // L·ª±c gi·∫≠t ng∆∞·ª£c l·∫°i cho ng∆∞·ªùi g√¢y va ch·∫°m
  // =========================================================================

  // TH√äM M·ªöI: D·ªØ li·ªáu l√≤ xo thu th·∫≠p t·ª´ WorldBuilder
  private springsData: { id: string; x: number; y: number }[] = [];

  // TH√äM M·ªöI: C·ªù ƒë·ªÉ ƒë·∫£m b·∫£o ƒëƒÉng k√Ω ch·ªâ x·∫£y ra m·ªôt l·∫ßn
  private hasRegisteredSprings: boolean = false;
  // TH√äM M·ªöI: Map ƒë·ªÉ theo d√µi state cu·ªëi c√πng c·ªßa m·ªói l√≤ xo
  private lastSpringStates: Map<string, string> = new Map();

  // === STRATEGY PATTERN COMPONENTS ===
  protected rules!: IPlatformerRules; // B·ªô quy t·∫Øc do subclass ch·ªçn
  protected logicCore!: PlatformerLogicCore; // Core logic v·ªõi rules
  protected minigameCore!: MinigameCore; // MinigameCore ƒë·ªÉ x·ª≠ l√Ω ƒëi·ªÉm v√† quiz

  // === CHUY√äN GIA HELPER ===
  private worldBuilder!: PlatformerWorldBuilder; // Chuy√™n gia x√¢y d·ª±ng th·∫ø gi·ªõi
  private playerHandler!: PlatformerPlayerHandler; // Chuy√™n gia v·ªÅ ng∆∞·ªùi ch∆°i

  // TH√äM M·ªöI: C√°c thu·ªôc t√≠nh ƒë·ªÉ qu·∫£n l√Ω checkpoint v√† spawn
  private spawnPoint!: { x: number; y: number };
  private lastCheckpoint: { x: number; y: number } | null = null;
  private isRespawning: boolean = false; // C·ªù ƒë·ªÉ tr√°nh respawn ch·ªìng ch√©o

  // === ENVIRONMENTAL EFFECTS ===
  protected environmentalEffect: IEnvironmentalEffect | null = null;

  /**
   * üé¨ PRELOAD - Load assets chung v√† ri√™ng cho platformer
   *
   * LU·ªíNG:
   * 1. Emit loading events cho React
   * 2. Load common platformer assets
   * 3. G·ªçi loadSceneSpecificAssets() ƒë·ªÉ subclass load ri√™ng
   * 4. Setup progress tracking
   */
  preload(): void {
    console.log(`üì¶ ${this.SCENE_NAME}: Loading assets...`);

    // Emit loading start event
    EventBus.emit("scene-loading-start", { sceneName: this.SCENE_NAME });

    // Setup progress tracking
    this.setupProgressTracking();

    // Load common platformer assets
    this.loadCommonAssets();

    // Load scene-specific assets (subclass implement)
    this.loadSceneSpecificAssets();
  }

  /**
   * üìä SETUP PROGRESS TRACKING - Setup loading progress events
   */
  private setupProgressTracking(): void {
    this.load.on("progress", (progress: number) => {
      EventBus.emit("scene-loading-progress", {
        progress: progress,
        sceneName: this.SCENE_NAME,
      });
    });

    this.load.on("complete", () => {
      EventBus.emit("scene-loading-complete", { sceneName: this.SCENE_NAME });
    });
  }

  /**
   * üì¶ LOAD COMMON ASSETS - Load assets chung cho t·∫•t c·∫£ platformer
   */
  private loadCommonAssets(): void {
    // Load tilemap JSON c·ªßa scene c·ª• th·ªÉ
    this.load.tilemapTiledJSON(this.TILEMAP_KEY, this.TILEMAP_PATH);

    // Load common tilesets (d√πng chung cho t·∫•t c·∫£ platformer)
    this.load.image(
      "spritesheet-tiles-default",
      "/kenney_new-platformer-pack-1.0/Spritesheets/spritesheet-tiles-default_extruded.png"
    );
    this.load.image(
      "spritesheet-backgrounds-default",
      "/kenney_new-platformer-pack-1.0/Spritesheets/spritesheet-backgrounds-default_extruded.png"
    );

    // Load character spritesheet (d√πng chung)
    this.load.image(
      "spritesheet-characters-default",
      "/kenney_new-platformer-pack-1.0/Spritesheets/spritesheet-characters-default.png"
    );

    // Load common sound effects
    this.load.audio(
      "coin",
      "/kenney_new-platformer-pack-1.0/Sounds/sfx_coin.ogg"
    );
    this.load.audio(
      "jump",
      "/kenney_new-platformer-pack-1.0/Sounds/sfx_jump.ogg"
    );
    this.load.audio(
      "hurt",
      "/kenney_new-platformer-pack-1.0/Sounds/sfx_hurt.ogg"
    );

    // TH√äM M·ªöI: Asset cho bom v√† v·ª• n·ªï (5 ·∫£nh tƒ©nh)
    this.load.image(
      "bomb",
      "/kenney_new-platformer-pack-1.0/Sprites/Tiles/Default/bomb.png"
    );
    this.load.image(
      "explosion_0",
      "/kenney_top-down-tanks-redux/PNG/Default size/explosion1.png"
    );
    this.load.image(
      "explosion_1",
      "/kenney_top-down-tanks-redux/PNG/Default size/explosion2.png"
    );
    this.load.image(
      "explosion_2",
      "/kenney_top-down-tanks-redux/PNG/Default size/explosion3.png"
    );
    this.load.image(
      "explosion_3",
      "/kenney_top-down-tanks-redux/PNG/Default size/explosion4.png"
    );
    this.load.image(
      "explosion_4",
      "/kenney_top-down-tanks-redux/PNG/Default size/explosion5.png"
    );

    // TH√äM M·ªöI: Load assets cho Mobile UI
    this.load.image(
      "dpad_left",
      "/mobile-controls-1/Sprites/Style C/Default/dpad_element_east.png"
    );
    this.load.image(
      "dpad_right",
      "/mobile-controls-1/Sprites/Style C/Default/dpad_element_west.png"
    );
    this.load.image(
      "button_jump",
      "/mobile-controls-1/Sprites/Icons/Default/icon_jump.png"
    );
    this.load.image(
      "button_grab",
      "/mobile-controls-1/Sprites/Icons/Default/icon_hand.png"
    );
  }

  /**
   * üì¶ LOAD SCENE SPECIFIC ASSETS - Abstract method cho subclass
   * Subclass override ƒë·ªÉ load assets ri√™ng cho scene ƒë√≥
   */
  protected abstract loadSceneSpecificAssets(): void;

  /**
   * üé¨ INITIALIZE SCENE - Implementation c·ªßa abstract method t·ª´ BaseGameScene
   *
   * LU·ªíNG M·ªöI v·ªõi STRATEGY PATTERN v√† NETWORK HANDLER:
   * 1. T·∫°o b·ªô quy t·∫Øc do scene con quy·∫øt ƒë·ªãnh (Strategy Pattern)
   * 2. Kh·ªüi t·∫°o c√°c chuy√™n gia Helper
   * 3. Kh·ªüi t·∫°o b·ªô quy t·∫Øc v·ªõi c√°c tham chi·∫øu c·∫ßn thi·∫øt
   * 4. D√πng WorldBuilder ƒë·ªÉ x√¢y d·ª±ng th·∫ø gi·ªõi
   * 5. Setup c√°c managers (Input, Camera, Timer)
   * 6. Kh·ªüi t·∫°o Network Handler
   * 7. LogicCore nh·∫≠n v√†o b·ªô quy t·∫Øc thay v√¨ scene
   * 8. Reset MinigameCore
   */
  protected initializeScene(): void {
    console.log(
      `üöÄ ${this.SCENE_NAME}: Orchestrating scene setup with Strategy Pattern...`
    );

    // 0. QUAN TR·ªåNG: Reset player ƒë·ªÉ tr√°nh conflict gi·ªØa c√°c round
    this.player = null as any;
    console.log(` ${this.SCENE_NAME}: Player reset for new round`);

    // TH√äM M·ªöI: Reset c·ªù khi scene b·∫Øt ƒë·∫ßu
    this.hasRegisteredBlocks = false;
    this.originalTiles.clear();
    this.lastBlockStates.clear();
    this.hasRegisteredSprings = false;
    this.interactiveTileSprites.clear();
    this.lastSpringStates.clear();

    // 1. T·∫°o b·ªô quy t·∫Øc do scene con quy·∫øt ƒë·ªãnh (Strategy Pattern)
    this.rules = this.createRules();
    console.log(` ${this.SCENE_NAME}: Rules created`);

    // 2. Kh·ªüi t·∫°o c√°c chuy√™n gia Helper v√† cores
    this.worldBuilder = new PlatformerWorldBuilder(this, this.TILEMAP_KEY);
    this.playerHandler = new PlatformerPlayerHandler(this);
    this.minigameCore = MinigameCore.getInstance();

    // 3. Kh·ªüi t·∫°o b·ªô quy t·∫Øc v·ªõi c√°c tham chi·∫øu c·∫ßn thi·∫øt
    this.rules.initialize(this, this.minigameCore);
    console.log(`üéØ ${this.SCENE_NAME}: Rules initialized`);

    // 4. LogicCore gi·ªù ch·ªâ nh·∫≠n b·ªô quy t·∫Øc - kh√¥ng c√≥ scene dependency
    this.logicCore = new PlatformerLogicCore(this.rules);
    console.log(
      `üéÆ ${this.SCENE_NAME}: Pure LogicCore created with rules only`
    );

    // 5. S·ª¨A ƒê·ªîI: D√πng chuy√™n gia ƒë·ªÉ x√¢y d·ª±ng th·∫ø gi·ªõi v√† nh·∫≠n l·∫°i d·ªØ li·ªáu l√≤ xo
    const { platformsLayer, foregroundLayer, springsData } =
      this.worldBuilder.build();
    this.platformsLayer = platformsLayer;
    this.foregroundLayer = foregroundLayer;
    this.springsData = springsData; // <-- L∆∞u l·∫°i d·ªØ li·ªáu l√≤ xo

    // T·ªêI ∆ØU MATTER.JS: D√πng colliders tƒ©nh t·ª´ Object Layer thay v√¨ convert c·∫£ tile layer
    try {
      const worldDims = this.worldBuilder.getWorldDimensions();
      this.matter.world.setBounds(0, 0, worldDims.width, worldDims.height);

      const tm = this.worldBuilder.getTilemap();
      const matterCollidersLayer = tm.getObjectLayer("MatterColliders");
      if (matterCollidersLayer && Array.isArray(matterCollidersLayer.objects)) {
        matterCollidersLayer.objects.forEach((obj: any) => {
          const x = obj.x ?? 0;
          const y = obj.y ?? 0;
          const width = obj.width ?? 0;
          const height = obj.height ?? 0;
          const cx = x + width / 2;
          const cy = y + height / 2;
          this.matter.add.rectangle(cx, cy, width, height, {
            isStatic: true,
            label: "Ground",
          } as any);
        });
        console.log(
          `[Matter.js] Created ${matterCollidersLayer.objects.length} optimized static colliders.`
        );
      } else {
        console.warn(
          "[Matter.js] 'MatterColliders' object layer not found in Tiled map."
        );
      }
    } catch {}

    // L∆∞u l·∫°i ƒëi·ªÉm spawn ban ƒë·∫ßu v√† reset checkpoint
    this.spawnPoint = this.worldBuilder.findPlayerSpawnPoint();
    this.lastCheckpoint = null;
    this.isRespawning = false; // Reset c·ªù respawn

    // 6. Setup c√°c managers (logic n√†y v·∫´n gi·ªØ l·∫°i v√¨ kh√° ƒë∆°n gi·∫£n)
    this.setupPlatformerManagers();

    // 7. Kh·ªüi t·∫°o chuy√™n gia m·∫°ng
    this.networkHandler = new PlatformerNetworkHandler(
      this,
      this.platformsLayer
    );

    // 8. L·∫§Y INSTANCE NetworkManager, KH√îNG K·∫æT N·ªêI
    this.networkManager = NetworkManager.getInstance();

    // X√ìA D√íNG N√ÄY: this.networkManager.joinGameRoom();
    // RoundManager s·∫Ω x·ª≠ l√Ω vi·ªác join room khi b·∫Øt ƒë·∫ßu v√≤ng.

    // 9. THAY ƒê·ªîI C√ÅCH ƒêƒÇNG K√ù LISTENER
    // X√≥a listener c≈© ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng b·ªã tr√πng l·∫∑p t·ª´ scene tr∆∞·ªõc
    if (this.networkConnectedHandler) {
      EventBus.off("network-connected", this.networkConnectedHandler);
    }

    // ƒê·ªãnh nghƒ©a h√†m x·ª≠ l√Ω v√† g√°n v√†o thu·ªôc t√≠nh v·ª´a t·∫°o
    this.networkConnectedHandler = (room: Room<GameRoomState>) => {
      // Ki·ªÉm tra scene ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ho√†n to√†n ch∆∞a
      if (!this.networkHandler || !this.playerHandler || !this.platformsLayer) {
        console.log(
          `üåê ${this.scene.key} received network-connected but scene not fully initialized. Ignoring.`
        );
        return;
      }

      // Ki·ªÉm tra scene c√≥ ƒëang visible kh√¥ng (b·ªè check isActive v√¨ n√≥ c√≥ th·ªÉ t·∫°m th·ªùi false)
      if (!this.scene.isVisible()) {
        console.log(
          `üåê ${
            this.scene.key
          } received network-connected but scene not visible. Visible: ${this.scene.isVisible()}. Ignoring.`
        );
        return;
      }

      console.log(
        `üåê network-connected event received in scene: ${this.scene.key}`
      );
      console.log(`üåê Room details:`, room.name, room.sessionId);
      this.room = room;
      this.networkHandler.initialize(room);

      // <-- S·ª¨A L·∫†I LISTENER onStateChange CHO G·ªåN G√ÄNG -->
      // S·ª≠ d·ª•ng onStateChange ƒë·ªÉ l·∫Øng nghe thay ƒë·ªïi to√†n b·ªô state
      this.room.onStateChange((state) => {
        if (state.players) {
          state.players.forEach(
            (playerState: PlayerStateSchema, sessionId: string) => {
              if (sessionId === this.room?.sessionId) {
                // Ch·ªâ c·∫ßn truy·ªÅn state cho Player object
                this.player?.setPlayerState(playerState);
              }
              // B·ªé H·∫æT LOGIC setPosition cho remote player ·ªü ƒë√¢y.
              // NetworkHandler s·∫Ω t·ª± x·ª≠ l√Ω.
            }
          );
        }
      });

      // TH√äM M·ªöI: B·∫Øt ƒë·∫ßu l·∫Øng nghe c√°c thay ƒë·ªïi tr·∫°ng th√°i c·ªßa block t·ª´ server
      this.listenToBlockChanges();

      // TH√äM M·ªöI: ƒêƒÉng k√Ω c√°c block c·ªßa map n√†y v·ªõi server
      this.registerBlocksWithServer();

      // TH√äM M·ªöI: B·∫Øt ƒë·∫ßu l·∫Øng nghe c√°c thay ƒë·ªïi tr·∫°ng th√°i c·ªßa l√≤ xo
      this.listenToSpringChanges();

      // TH√äM M·ªöI: ƒêƒÉng k√Ω c√°c l√≤ xo c·ªßa map n√†y v·ªõi server
      this.registerSpringsWithServer();

      // TH√äM M·ªöI: G·ª≠i v·ªã tr√≠ bomb spawners l√™n server (n·∫øu c√≥)
      const bombSpawners = this.worldBuilder.findBombSpawners();
      if (bombSpawners && bombSpawners.length > 0) {
        this.room.send("registerBombSpawners", bombSpawners);
        console.log(
          `[Client] Registered ${bombSpawners.length} bomb spawners with server.`
        );
      }

      // DEBUG: Ki·ªÉm tra room state
      console.log("[Client] Room state after connection:", this.room.state);
      console.log(
        "[Client] DisappearingBlocks in state:",
        this.room.state.disappearingBlocks
      );

      // ======================== TH√äM LISTENER CHO L·ªÜNH KNOCKBACK T·ª™ SERVER ========================
      this.room.onMessage(
        "applyKnockback",
        (message: { forceX: number; forceY: number }) => {
          // Ch·ªâ player ch√≠nh m·ªõi th·ª±c thi l·ªánh n√†y
          if (this.player) {
            console.log(`[Scene] Received applyKnockback command from server.`);
            this.player.applyKnockback(message.forceX, message.forceY);
          }
        }
      );
      // =========================================================================
    };

    // ƒêƒÉng k√Ω listener b·∫±ng thu·ªôc t√≠nh ƒë√≥
    EventBus.on("network-connected", this.networkConnectedHandler);

    // 10. Reset game core
    this.minigameCore.resetForNewRound();

    // TH√äM M·ªöI: Ch·ªß ƒë·ªông emit tr·∫°ng th√°i ƒëi·ªÉm s·ªë ban ƒë·∫ßu
    // Sau khi resetForNewRound, ƒëi·ªÉm s·ªë ƒë∆∞·ª£c gi·ªØ l·∫°i t·ª´ c√°c v√≤ng tr∆∞·ªõc.
    // Ch√∫ng ta c·∫ßn th√¥ng b√°o cho UI bi·∫øt gi√° tr·ªã n√†y.
    EventBus.emit("minigame-score-updated", {
      oldScore: this.minigameCore.getCurrentScore(),
      newScore: this.minigameCore.getCurrentScore(),
      change: 0,
    });

    console.log(
      `‚úÖ ${this.SCENE_NAME} initialization completed. Waiting for RoundManager to join room.`
    );

    // Emit event ƒë·ªÉ NetworkManager bi·∫øt Scene ƒë√£ s·∫µn s√†ng
    EventBus.emit("scene-ready-for-network", this.SCENE_NAME);

    // TH√äM M·ªöI: L·∫Øng nghe s·ª± ki·ªán ƒë·ªÉ ƒëi·ªÅu khi·ªÉn UI di ƒë·ªông
    this.registerMobileUIEventListeners();

    // Th√¥ng b√°o cho React component r·∫±ng scene ƒë√£ s·∫µn s√†ng (failsafe cho loading overlay)
    this.notifySceneReady();
  }

  /**
   * ‚öôÔ∏è SETUP PLATFORMER MANAGERS - Kh·ªüi t·∫°o managers chung cho platformer
   */
  private setupPlatformerManagers(): void {
    // Input Manager - x·ª≠ l√Ω input PC (Arrow keys, WASD, Space)
    this.inputManager = new InputManager(this);

    // TH√äM M·ªöI: Ki·ªÉm tra thi·∫øt b·ªã ƒë·ªÉ quy·∫øt ƒë·ªãnh b·∫≠t Mobile UI
    this.isMobile =
      (this.sys.game.device.os as any).android ||
      (this.sys.game.device.os as any).iOS ||
      this.cameras.main.width < 1024;

    if (this.isMobile) {
      console.log("üì± Mobile device detected. Creating mobile UI controls.");
      // √Åp d·ª•ng c·∫•u h√¨nh ch·∫°m cho mobile (ch·∫∑n long-press/select/context menu)
      this.applyMobileTouchDefaults();
      this.mobileUIHandler = new MobileUIHandler(this, this.inputManager);
      this.mobileUIHandler.hide();
    }

    // Camera Manager - follow player v·ªõi config chu·∫©n (adjust zoom for mobile)
    const worldDimensions = this.worldBuilder.getWorldDimensions();
    this.cameraManager = new CameraManager(this, {
      followOffset: CAMERA_CONFIG.DEFAULT_OFFSET,
      lerpSpeed: CAMERA_CONFIG.LERP_SPEED,
      bounds: {
        x: 0,
        y: 0,
        width: worldDimensions.width,
        height: worldDimensions.height,
      },
      zoom: this.isMobile ? 0.8 : 1.2,
    });

    // Timer Manager
    this.timerManager = new TimerManager(this);
    this.startPlatformerGameTimer();

    console.log("‚öôÔ∏è Platformer managers initialized");
  }

  /**
   * ‚è∞ START PLATFORMER GAME TIMER - B·∫Øt ƒë·∫ßu timer chung cho platformer
   */
  private startPlatformerGameTimer(): void {
    const gameTimeLimit =
      this.getRoundData()?.gameTimeLimit || TIMER_CONFIG.GAME_TIME_LIMIT;

    this.timerManager.startTimer({
      duration: gameTimeLimit,
      onTimeUp: () => {
        console.log(`‚è∞ ${this.SCENE_NAME} time up! Auto triggering quiz...`);
      },
      onWarning: (timeLeft: number) => {
        console.log(
          `‚ö†Ô∏è ${this.SCENE_NAME} time warning: ${this.timerManager.formatTime(
            timeLeft
          )} left`
        );
      },
      onTick: (timeLeft: number) => {
        EventBus.emit("game-timer-update", {
          timeLeft,
          formatted: this.timerManager.formatTime(timeLeft),
          isWarning: this.timerManager.isInWarningTime(),
        });
      },
    });

    // TH√äM M·ªöI: Ch·ªß ƒë·ªông emit tr·∫°ng th√°i timer ban ƒë·∫ßu
    // Ngay sau khi timer b·∫Øt ƒë·∫ßu, h√£y g·ª≠i tr·∫°ng th√°i ƒë·∫ßu ti√™n cho UI.
    EventBus.emit("game-timer-update", {
      timeLeft: gameTimeLimit,
      formatted: this.timerManager.formatTime(gameTimeLimit),
      isWarning: false,
    });
  }

  // === MULTIPLAYER METHODS ===

  /**
   * üéØ CREATE MAIN PLAYER - ƒê∆∞·ª£c g·ªçi b·ªüi NetworkHandler ƒë·ªÉ t·∫°o ng∆∞·ªùi ch∆°i ch√≠nh
   * @param playerState Tr·∫°ng th√°i ban ƒë·∫ßu t·ª´ server
   */
  public createMainPlayer(playerState: PlayerStateSchema): void {
    // S·ª¨A ƒê·ªîI: S·ª≠ d·ª•ng this.spawnPoint ƒë√£ l∆∞u thay v√¨ g·ªçi l·∫°i worldBuilder
    const spawnPoint = this.spawnPoint;

    console.log(
      `üéØ createMainPlayer called. Server suggested: (${playerState.x}, ${playerState.y}), Map requires: (${spawnPoint.x}, ${spawnPoint.y})`
    );

    console.log(
      `üéÆ Creating main player at correct map position: ${spawnPoint.x}, ${spawnPoint.y}`
    );

    // üîß Null checks tr∆∞·ªõc khi t·∫°o player
    if (!this.playerHandler) {
      console.error(`‚ùå PlayerHandler is null in ${this.scene.key}`);
      return;
    }
    if (!this.platformsLayer) {
      console.error(`‚ùå PlatformsLayer is null in ${this.scene.key}`);
      return;
    }
    if (!this.inputManager) {
      console.error(`‚ùå InputManager is null in ${this.scene.key}`);
      return;
    }

    console.log(`üîß Creating player with playerHandler:`, !!this.playerHandler);

    // T·∫°o player t·∫°i v·ªã tr√≠ ƒê√öNG t·ª´ map
    this.player = this.playerHandler.spawnPlayer(
      spawnPoint, // <--- S·ª¨A ·ªû ƒê√ÇY: S·ª≠ d·ª•ng spawnPoint t·ª´ map thay v√¨ t·ª´ server
      this.platformsLayer,
      this.inputManager,
      this.cameraManager,
      this.logicCore,
      this.networkManager
    );

    // üîß Ki·ªÉm tra xem player c√≥ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng kh√¥ng
    if (!this.player) {
      console.error(`‚ùå Failed to create player in ${this.scene.key}`);
      return;
    }

    // Sau khi t·∫°o xong, g·ª≠i m·ªôt b·∫£n c·∫≠p nh·∫≠t v·ªã tr√≠ l√™n server ngay l·∫≠p t·ª©c
    // ƒë·ªÉ c√°c ng∆∞·ªùi ch∆°i kh√°c th·∫•y ƒë√∫ng v·ªã tr√≠ c·ªßa b·∫°n.
    const sprite = this.player.getSprite();
    if (sprite) {
      this.networkManager.sendUpdate({
        x: Math.round(sprite.x),
        y: Math.round(sprite.y),
        animState: "idle",
        flipX: false,
      });
    }

    // TH√äM M·ªöI: Setup collision ƒë∆°n gi·∫£n
    this.setupSimplePlayerCollision();

    // Setup interactive objects CH·ªà SAU KHI player ch√≠nh ƒë∆∞·ª£c t·∫°o
    this.worldBuilder.setupInteractiveObjects(
      this.player.getSprite(),
      this.logicCore
    );

    console.log(
      `‚úÖ Main player created successfully at correct map position: ${spawnPoint.x}, ${spawnPoint.y}`
    );

    // B∆Ø·ªöC QUAN TR·ªåNG: Ph√°t ra s·ª± ki·ªán b√°o cho UI bi·∫øt game ƒë√£ th·ª±c s·ª± s·∫µn s√†ng
    EventBus.emit("player-ready-and-visible", { sceneKey: this.scene.key });
    console.log(`üì¢ Emitted player-ready-and-visible event!`);

    // UX: T·∫°m d·ª´ng scene cho ƒë·∫øn khi ng∆∞·ªùi ch∆°i th·∫≠t s·ª± s·∫µn s√†ng
    console.log(
      `‚è∏Ô∏è ${this.SCENE_NAME}: Pausing scene, waiting for user to start.`
    );
    this.scene.pause();

    // Ch·ªâ l·∫Øng nghe m·ªôt l·∫ßn ƒë·ªÉ ti·∫øp t·ª•c khi ng∆∞·ªùi ch∆°i nh·∫•n b·∫Øt ƒë·∫ßu
    const resumeGame = () => {
      console.log(`‚ñ∂Ô∏è ${this.SCENE_NAME}: Resuming scene on user start.`);
      this.scene.resume();
    };
    EventBus.once("scene-loading-user-start", resumeGame);
  }

  /**
   * THAY ƒê·ªîI L·ªöN: T√°i c·∫•u tr√∫c ho√†n to√†n logic va ch·∫°m gi·ªØa c√°c ng∆∞·ªùi ch∆°i
   */
  private setupSimplePlayerCollision(): void {
    if (!this.player || !this.networkHandler) return;

    const mainPlayerSprite = this.player.getSprite();
    const remotePlayersGroup = this.networkHandler.getRemotePlayersGroup();

    this.physics.add.collider(
      mainPlayerSprite,
      remotePlayersGroup,
      undefined, // Kh√¥ng c·∫ßn callback va ch·∫°m c·ª©ng
      this.processPlayerCollision, // Callback ƒëi·ªÅu ki·ªán t·ªëi quan tr·ªçng
      this
    );

    console.log(
      "ü§ù Advanced player collision enabled with PAIR-SPECIFIC logic."
    );
  }

  /**
   * H√ÄM N√ÇNG C·∫§P: "B·ªô n√£o" quy·∫øt ƒë·ªãnh va ch·∫°m gi·ªØa T·ª™NG C·∫∂P ng∆∞·ªùi ch∆°i
   *
   * ƒê∆∞·ª£c g·ªçi m·ªói frame khi hai ng∆∞·ªùi ch∆°i s·∫Øp va ch·∫°m.
   * Tr·∫£ v·ªÅ `true` ƒë·ªÉ cho ph√©p va ch·∫°m (ch·∫∑n nhau).
   * Tr·∫£ v·ªÅ `false` ƒë·ªÉ v√¥ hi·ªáu h√≥a va ch·∫°m (ƒëi xuy√™n qua nhau).
   */
  private processPlayerCollision = (
    mainPlayerSprite: any,
    remotePlayerSprite: any
  ): boolean => {
    // --- B∆Ø·ªöC 1: L·∫§Y C√ÅC TH√îNG TIN C·∫¶N THI·∫æT ---
    const mainPlayerBody = mainPlayerSprite.body as Phaser.Physics.Arcade.Body;
    const remoteBody = remotePlayerSprite.body as Phaser.Physics.Arcade.Body;
    remoteBody.setImmovable(true);

    const mainPlayerState = this.player.playerState;
    if (!mainPlayerState || !this.room) {
      return true;
    }
    const remoteSessionId =
      this.networkHandler.getSessionIdBySprite(remotePlayerSprite);
    if (!remoteSessionId) {
      return true;
    }

    // --- B∆Ø·ªöC 2: KI·ªÇM TRA ∆ØU TI√äN - C√ì ƒêANG N·∫ÆM NHAU KH√îNG? ---
    const isMainPlayerGrabbingThisRemote =
      mainPlayerState.isGrabbing === remoteSessionId;
    const isMainPlayerGrabbedByThisRemote =
      mainPlayerState.grabbedBy === remoteSessionId;

    if (isMainPlayerGrabbingThisRemote || isMainPlayerGrabbedByThisRemote) {
      return false; // Cho ph√©p ƒëi xuy√™n qua v√† d·ª´ng m·ªçi x·ª≠ l√Ω ph√≠a d∆∞·ªõi
    }

    // --- B∆Ø·ªöC 3: KI·ªÇM TRA VA CH·∫†M T·ªêC ƒê·ªò CAO ---
    const currentVelocity = mainPlayerBody.velocity.length();
    if (currentVelocity > this.IMPACT_VELOCITY_THRESHOLD) {
      console.log(
        `üí• IMPACT! Player hit ${remoteSessionId} with velocity ${currentVelocity.toFixed(
          0
        )}`
      );

      this.room.send("playerImpact", {
        targetSessionId: remoteSessionId,
        impactX: mainPlayerBody.velocity.x,
        impactY: mainPlayerBody.velocity.y,
      });

      // √Åp d·ª•ng l·ª±c gi·∫≠t ng∆∞·ª£c (recoil)
      mainPlayerBody.velocity.x *= this.IMPACT_RECOIL_FACTOR;
      mainPlayerBody.velocity.y *= this.IMPACT_RECOIL_FACTOR;
      //this.cameraManager.shake(0.008, 120);

      // Cho ƒëi xuy√™n qua ƒë·ªÉ tr√°nh k·∫πt l·∫°i ngay sau va ch·∫°m m·∫°nh
      return false;
    }

    // --- B∆Ø·ªöC 4: X·ª¨ L√ù VA CH·∫†M TH√îNG TH∆Ø·ªúNG ---
    return this.checkCanStandOnTop(mainPlayerSprite, remotePlayerSprite);
  };

  /**
   * H√ÄM C≈®: ƒê∆∞·ª£c t√°i s·ª≠ d·ª•ng, ch·ªâ ki·ªÉm tra logic ƒë·ª©ng tr√™n ƒë·∫ßu
   */
  private checkCanStandOnTop = (
    mainPlayerSprite: any,
    remotePlayerSprite: any
  ): boolean => {
    const mainPlayerBody = mainPlayerSprite.body as Phaser.Physics.Arcade.Body;
    const remotePlayerBody =
      remotePlayerSprite.body as Phaser.Physics.Arcade.Body;

    if (!mainPlayerBody || !remotePlayerBody) {
      return true;
    }

    const tolerance = 5; // TƒÉng ƒë·ªô dung sai m·ªôt ch√∫t
    const isFallingOnTop =
      mainPlayerBody.velocity.y > 0 &&
      mainPlayerBody.bottom <= remotePlayerBody.top + tolerance;

    // N·∫øu ƒëang ƒë·ª©ng tr√™n ƒë·∫ßu, ch√∫ng ta c·∫ßn ƒë·∫£m b·∫£o va ch·∫°m ch·ªâ x·∫£y ra t·ª´ ph√≠a tr√™n
    if (isFallingOnTop) {
      mainPlayerBody.velocity.y = 0; // NgƒÉn kh√¥ng b·ªã l√∫n xu·ªëng
      return true;
    }

    // C√°c tr∆∞·ªùng h·ª£p kh√°c (va ch·∫°m ngang)
    return true; // Cho ph√©p va ch·∫°m nh∆∞ b·ª©c t∆∞·ªùng
  };

  // === UPDATE LOOP ===

  /**
   * üéÆ UPDATE - Game loop c·ª±c k·ª≥ g·ªçn g√†ng v·ªõi Network Handler
   */
  update(): void {
    // Ch·ªâ c·∫ßn ra l·ªánh cho c√°c th√†nh ph·∫ßn t·ª± c·∫≠p nh·∫≠t
    this.player?.update();
    this.networkHandler?.update();
    // TH√äM M·ªöI: C·∫≠p nh·∫≠t tr·∫°ng th√°i c√°t l√∫n cho player handler
    this.playerHandler?.update();

    // TH√äM M·ªöI: G·ªçi update c·ªßa b·ªô lu·∫≠t m·ªói frame
    this.rules?.update();

    // C·∫≠p nh·∫≠t hi·ªáu ·ª©ng m√¥i tr∆∞·ªùng n·∫øu c√≥
    if (this.environmentalEffect && this.player) {
      this.environmentalEffect.update(this.player);
    }
  }

  // === PUBLIC API - Cho React components ===

  /**
   * TH√äM M·ªöI: Cung c·∫•p m·ªôt ph∆∞∆°ng th·ª©c c√¥ng khai ƒë·ªÉ Rules c√≥ th·ªÉ truy c·∫≠p Player.
   * ƒêi·ªÅu n√†y t·ªët h∆°n l√† cho Rules truy c·∫≠p tr·ª±c ti·∫øp v√†o thu·ªôc t√≠nh `this.player`.
   * @returns Player instance ho·∫∑c null n·∫øu ch∆∞a ƒë∆∞·ª£c t·∫°o.
   */
  public getPlayer(): Player | null {
    return this.player || null;
  }

  /**
   * üìç GET PLAYER POSITION - API cho React
   */
  public getPlayerPosition() {
    return this.player ? this.player.getPosition() : null;
  }

  /**
   * ‚è∏Ô∏è PAUSE GAME TIMER - API cho React
   */
  public pauseGameTimer(): void {
    this.timerManager.pauseTimer();
  }

  /**
   * ‚ñ∂Ô∏è RESUME GAME TIMER - API cho React
   */
  public resumeGameTimer(): void {
    this.timerManager.resumeTimer();
  }

  /**
   * üó∫Ô∏è GET TILEMAP - API ƒë·ªÉ truy c·∫≠p tilemap th√¥ng qua WorldBuilder
   */
  public getTilemap(): Phaser.Tilemaps.Tilemap {
    return this.worldBuilder.getTilemap();
  }

  /**
   * üìê GET WORLD DIMENSIONS - API ƒë·ªÉ l·∫•y k√≠ch th∆∞·ªõc th·∫ø gi·ªõi
   */
  public getWorldDimensions(): { width: number; height: number } {
    return this.worldBuilder.getWorldDimensions();
  }

  // === CONFIGURATION HOOKS - Subclass c√≥ th·ªÉ override ===

  /**
   * üë§ GET CHARACTER DATA - Hook ƒë·ªÉ subclass ch·ªçn character
   * Default: ORANGE character
   */
  public getCharacterData() {
    return CHARACTERS.ORANGE;
  }

  /**
   * ‚ö° GET PLAYER PHYSICS CONFIG - Hook ƒë·ªÉ subclass custom physics
   * Default: Standard platformer physics
   */
  public getPlayerPhysicsConfig() {
    return {
      speed: 200,
      jumpPower: 700,
      gravity: 800,
      bounce: 0.2,
    };
  }

  /**
   * üë§ GET USER DISPLAY NAME - L·∫•y t√™n hi·ªÉn th·ªã c·ªßa ng∆∞·ªùi ch∆°i
   * Default: "You"
   */
  public getUserDisplayName(): string {
    const userData = this.getRoundData()?.user;
    // ∆Øu ti√™n fullName, sau ƒë√≥ name, cu·ªëi c√πng fallback
    return userData?.fullName || userData?.name || userData?.username || "You";
  }

  // === DISAPPEARING BLOCKS LOGIC ===

  /**
   * TH√äM M·ªöI: Qu√©t tilemap, t√¨m v√† g·ª≠i th√¥ng tin c√°c block bi·∫øn m·∫•t l√™n server.
   */
  private registerBlocksWithServer(): void {
    if (!this.room) {
      console.error("[Client] Cannot register blocks: no room available");
      return;
    }

    if (this.hasRegisteredBlocks) {
      console.log("[Client] Blocks already registered, skipping");
      return;
    }

    console.log("[Client] Scanning tilemap for disappearing blocks...");
    const blocksData: { id: string; x: number; y: number }[] = [];

    this.platformsLayer.forEachTile((tile) => {
      if (tile && (tile.properties as any).behavior === "disappearing") {
        const tileId = `${tile.x}_${tile.y}`;
        blocksData.push({ id: tileId, x: tile.x, y: tile.y });

        // L∆∞u l·∫°i tile g·ªëc ƒë·ªÉ c√≥ th·ªÉ t√¨m v√† thao t√°c sau n√†y
        this.originalTiles.set(tileId, tile);
        console.log(
          `[Client] Found disappearing block: ${tileId} at (${tile.x}, ${tile.y})`
        );
      }
    });

    if (blocksData.length > 0) {
      console.log(
        `[Client] Registering ${blocksData.length} disappearing blocks with server:`,
        blocksData
      );
      this.room.send("registerDisappearingBlocks", blocksData);
      this.hasRegisteredBlocks = true; // ƒê√°nh d·∫•u ƒë√£ ƒëƒÉng k√Ω
    } else {
      console.log("[Client] No disappearing blocks found in tilemap");
    }
  }

  /**
   * TH√äM M·ªöI: L·∫Øng nghe v√† ph·∫£n h·ªìi c√°c thay ƒë·ªïi tr·∫°ng th√°i t·ª´ server.
   */
  private listenToBlockChanges(): void {
    if (!this.room) {
      console.error(
        "[Client] Cannot listen to block changes: no room available"
      );
      return;
    }

    console.log("[Client] Setting up block change listeners...");

    // S·ª≠ d·ª•ng onStateChange ƒë·ªÉ l·∫Øng nghe t·∫•t c·∫£ thay ƒë·ªïi
    this.room.onStateChange((state: any) => {
      console.log(
        "[Client] Room state changed, checking disappearing blocks..."
      );

      if (state.disappearingBlocks) {
        state.disappearingBlocks.forEach((block: any, blockId: string) => {
          // Ki·ªÉm tra xem state c·ªßa block n√†y c√≥ thay ƒë·ªïi kh√¥ng
          const currentState = block.state;
          const lastKnownState = this.lastBlockStates.get(blockId);

          if (lastKnownState !== currentState) {
            console.log(
              `[Client] Block ${blockId} state changed from ${lastKnownState} to ${currentState}`
            );
            this.updateTileVisuals(blockId, currentState);
            this.lastBlockStates.set(blockId, currentState);
          }
        });
      }
    });

    console.log("[Client] Block change listeners setup completed");
  }

  /**
   * TH√äM M·ªöI: H√†m trung t√¢m ƒë·ªÉ c·∫≠p nh·∫≠t h√¨nh ·∫£nh c·ªßa tile d·ª±a tr√™n state t·ª´ server.
   */
  private updateTileVisuals(blockId: string, state: string): void {
    const tile = this.originalTiles.get(blockId);
    if (!tile) {
      console.warn(
        `[Client] Cannot find original tile for blockId: ${blockId}`
      );
      return;
    }
    const layer = this.platformsLayer;

    console.log(
      `[Client] Updating tile visuals for ${blockId} to state: ${state}`
    );

    switch (state) {
      case "triggered":
        const existingTileTriggered = layer.getTileAt(tile.x, tile.y);
        if (existingTileTriggered) {
          this.tweens.add({
            targets: existingTileTriggered,
            alpha: 0.2,
            yoyo: true,
            repeat: 5,
            duration: 150,
          });
          console.log(`[Client] Started shake animation for tile ${blockId}`);
        }
        break;
      case "gone":
        // QUAN TR·ªåNG: X√≥a tile v√† c·∫≠p nh·∫≠t collision
        const removedTile = layer.removeTileAt(tile.x, tile.y);
        if (removedTile) {
          // C·∫≠p nh·∫≠t collision map ƒë·ªÉ tile kh√¥ng c√≤n collision
          layer.setCollisionByProperty({ collides: true }); // Refresh collision
          console.log(`[Client] Removed tile ${blockId} and updated collision`);
        }
        break;
      case "idle":
        // Ch·ªâ ƒë·∫∑t l·∫°i tile n·∫øu n√≥ ch∆∞a t·ªìn t·∫°i ·ªü ƒë√≥
        if (!layer.hasTileAt(tile.x, tile.y)) {
          const newTile = layer.putTileAt(tile.index, tile.x, tile.y);
          if (newTile) {
            // Kh√¥i ph·ª•c properties t·ª´ tile g·ªëc
            Object.assign(newTile.properties, tile.properties);
            newTile.setAlpha(1); // ƒê·∫£m b·∫£o n√≥ hi·ªán r√µ

            // QUAN TR·ªåNG: C·∫≠p nh·∫≠t collision cho tile m·ªõi
            if (tile.properties.collides) {
              newTile.setCollision(true);
            }
            layer.setCollisionByProperty({ collides: true }); // Refresh collision
            console.log(`[Client] Restored tile ${blockId} with collision`);
          }
        }
        break;
    }
  }

  /**
   * S·ª¨A ƒê·ªîI HO√ÄN TO√ÄN: H√†m n√†y gi·ªù x·ª≠ l√Ω nhi·ªÅu lo·∫°i tile kh√°c nhau.
   */
  // Tile-specific interaction methods have been moved to Behavior classes

  // === CLEANUP ===

  /**
   * üóëÔ∏è CLEANUP ON SHUTDOWN - Override t·ª´ BaseGameScene
   */
  protected cleanupOnShutdown(): void {
    console.log(`üóëÔ∏è ${this.SCENE_NAME}: Starting cleanup...`);

    // D·ªçn d·∫πp hi·ªáu ·ª©ng m√¥i tr∆∞·ªùng n·∫øu c√≥
    this.environmentalEffect?.cleanup();
    this.environmentalEffect = null;

    // D·ªçn d·∫πp Mobile UI Handler
    this.mobileUIHandler?.destroy();
    this.mobileUIHandler = undefined;

    // G·ª° c√°c listener/tweaks cho mobile n·∫øu c√≥
    try {
      this.mobileTouchCleanupFns.forEach((fn) => fn());
    } catch {}
    this.mobileTouchCleanupFns = [];

    super.cleanupOnShutdown();

    // G·ª† B·ªé LISTENER KHI SCENE B·ªä H·ª¶Y
    // ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng nh·∫•t ƒë·ªÉ s·ª≠a l·ªói
    if (this.networkConnectedHandler) {
      EventBus.off("network-connected", this.networkConnectedHandler);
      console.log(`üóëÔ∏è ${this.SCENE_NAME}: Removed network-connected listener.`);
      this.networkConnectedHandler = null as any;
    }

    // Ra l·ªánh cho c√°c chuy√™n gia t·ª± d·ªçn d·∫πp
    this.networkHandler?.cleanup();
    this.networkManager?.leaveCurrentRoom();

    // QUAN TR·ªåNG: Cleanup player tr∆∞·ªõc khi chuy·ªÉn scene
    if (this.player) {
      console.log(`üóëÔ∏è ${this.SCENE_NAME}: Cleaning up player`);
      this.player.destroy();
      this.player = null as any;
    }

    // Cleanup b·ªô quy t·∫Øc TR∆Ø·ªöC khi cleanup c√°c component kh√°c
    this.rules?.cleanup();

    // Cleanup platformer-specific resources
    this.timerManager?.destroy();
    this.logicCore?.cleanup();

    // Cleanup network handler ƒë·ªÉ tr√°nh duplicate events
    this.networkHandler?.cleanup();

    // Cleanup c√°c chuy√™n gia helpers
    this.worldBuilder?.cleanup();
    this.playerHandler?.cleanup();

    console.log(`üóëÔ∏è ${this.SCENE_NAME} platformer cleanup completed.`);
  }

  // TH√äM M·ªöI: Qu·∫£n l√Ω event listeners cho Mobile UI
  private registerMobileUIEventListeners(): void {
    if (!this.isMobile) return;

    const requestFullscreen = () => {
      try {
        if (!this.scale.isFullscreen) {
          this.scale.startFullscreen();
        }
      } catch (e) {
        // Tr√¨nh duy·ªát c√≥ th·ªÉ y√™u c·∫ßu user gesture; ta s·∫Ω g·ªçi l·∫°i ·ªü pointerdown
      }
    };

    // Y√™u c·∫ßu fullscreen ·ªü l·∫ßn ch·∫°m ƒë·∫ßu ti√™n (ƒë·∫£m b·∫£o c√≥ user gesture)
    this.input.once("pointerdown", requestFullscreen, this);

    const showControls = () => {
      this.mobileUIHandler?.show();
      requestFullscreen();
    };
    const hideControls = () => this.mobileUIHandler?.hide();

    EventBus.on("scene-loading-user-start", showControls, this);
    EventBus.on("show-quiz-overlay", hideControls, this);
    EventBus.on("quiz-completed", hideControls, this);

    this.events.on(
      Phaser.Scenes.Events.SHUTDOWN,
      () => {
        EventBus.off("scene-loading-user-start", showControls, this);
        EventBus.off("show-quiz-overlay", hideControls, this);
        EventBus.off("quiz-completed", hideControls, this);
      },
      this
    );
  }

  // TH√äM M·ªöI: √Åp d·ª•ng c·∫•u h√¨nh ch·∫°m ƒë·ªÉ tr√°nh long-press m·ªü menu h·ªá th·ªëng
  private applyMobileTouchDefaults(): void {
    try {
      const canvas = this.game.canvas as HTMLCanvasElement;
      if (canvas && canvas.style) {
        canvas.style.touchAction = "none"; // ch·∫∑n gesture m·∫∑c ƒë·ªãnh
        (canvas.style as any).webkitUserSelect = "none";
        canvas.style.userSelect = "none";
        (canvas.style as any).webkitTouchCallout = "none";
        (canvas.style as any).msUserSelect = "none";
        (canvas.style as any).webkitTapHighlightColor = "rgba(0,0,0,0)";
      }
      // Ch·∫∑n context menu (chu·ªôt ph·∫£i / long-press)
      const phaserMouse = (this.input as any).mouse;
      if (phaserMouse && phaserMouse.disableContextMenu) {
        phaserMouse.disableContextMenu();
      }
      // Ch·∫∑n s·ª± ki·ªán contextmenu tr√™n canvas ·ªü m·ªôt s·ªë tr√¨nh duy·ªát
      if (canvas) {
        const ctxHandler = (e: Event) => e.preventDefault();
        canvas.addEventListener("contextmenu", ctxHandler, { passive: false });
        this.mobileTouchCleanupFns.push(() =>
          canvas.removeEventListener("contextmenu", ctxHandler)
        );

        // Ch·∫∑n double-tap zoom
        let lastTouchEnd = 0;
        const touchEndHandler = (e: TouchEvent) => {
          const now = Date.now();
          if (now - lastTouchEnd <= 350) {
            e.preventDefault();
          }
          lastTouchEnd = now;
        };
        canvas.addEventListener("touchend", touchEndHandler, {
          passive: false,
        });
        this.mobileTouchCleanupFns.push(() =>
          canvas.removeEventListener("touchend", touchEndHandler)
        );

        // Ch·∫∑n pinch-zoom (nhi·ªÅu ng√≥n)
        const touchStartHandler = (e: TouchEvent) => {
          if (e.touches && e.touches.length > 1) {
            e.preventDefault();
          }
        };
        canvas.addEventListener("touchstart", touchStartHandler, {
          passive: false,
        });
        this.mobileTouchCleanupFns.push(() =>
          canvas.removeEventListener("touchstart", touchStartHandler)
        );

        // Ch·∫∑n dblclick zoom tr√™n m·ªôt s·ªë tr√¨nh duy·ªát
        const dblHandler = (e: MouseEvent) => e.preventDefault();
        canvas.addEventListener(
          "dblclick",
          dblHandler as any,
          { passive: false } as any
        );
        this.mobileTouchCleanupFns.push(() =>
          canvas.removeEventListener("dblclick", dblHandler as any)
        );

        // iOS Safari: ch·∫∑n gesture pinch
        const gesturePrevent = (e: Event) => e.preventDefault();
        canvas.addEventListener(
          "gesturestart" as any,
          gesturePrevent as any,
          { passive: false } as any
        );
        canvas.addEventListener(
          "gesturechange" as any,
          gesturePrevent as any,
          { passive: false } as any
        );
        canvas.addEventListener(
          "gestureend" as any,
          gesturePrevent as any,
          { passive: false } as any
        );
        this.mobileTouchCleanupFns.push(() => {
          canvas.removeEventListener(
            "gesturestart" as any,
            gesturePrevent as any
          );
          canvas.removeEventListener(
            "gesturechange" as any,
            gesturePrevent as any
          );
          canvas.removeEventListener(
            "gestureend" as any,
            gesturePrevent as any
          );
        });

        // Desktop: ch·∫∑n ctrl/meta + wheel zoom tr√™n canvas
        const wheelHandler = (e: WheelEvent) => {
          if ((e.ctrlKey as boolean) || (e as any).metaKey) {
            e.preventDefault();
          }
        };
        canvas.addEventListener("wheel", wheelHandler, { passive: false });
        this.mobileTouchCleanupFns.push(() =>
          canvas.removeEventListener("wheel", wheelHandler)
        );
      }

      // ƒê·∫∑t meta viewport ƒë·ªÉ v√¥ hi·ªáu h√≥a zoom ng∆∞·ªùi d√πng
      const head = document.head || document.getElementsByTagName("head")[0];
      let meta = document.querySelector(
        'meta[name="viewport"]'
      ) as HTMLMetaElement | null;
      const desired =
        "width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no";
      if (!meta) {
        meta = document.createElement("meta");
        meta.name = "viewport";
        meta.content = desired;
        head?.appendChild(meta);
      } else {
        meta.content = desired;
      }
    } catch (e) {
      // an to√†n: kh√¥ng l√†m g√¨ n·∫øu DOM kh√¥ng s·∫µn s√†ng
    }
  }

  /**
   * ‚è∏Ô∏è ON PAUSE - Override t·ª´ BaseGameScene
   */
  protected onPause(): void {
    super.onPause();
    this.pauseGameTimer();
  }

  /**
   * ‚ñ∂Ô∏è ON RESUME - Override t·ª´ BaseGameScene
   */
  protected onResume(): void {
    super.onResume();
    this.resumeGameTimer();
  }

  // ===============================================
  // === C√ÅC PH∆Ø∆†NG TH·ª®C CHO T√çNH NƒÇNG N·∫ÆM V√Ä THO√ÅT ===
  // ===============================================

  /**
   * T√¨m ng∆∞·ªùi ch∆°i kh√°c g·∫ßn nh·∫•t trong m·ªôt kho·∫£ng c√°ch.
   */
  public findClosestRemotePlayer(
    x: number,
    y: number,
    maxDistance: number
  ): { sessionId: string; distance: number } | null {
    return this.networkHandler.findClosestRemotePlayer(x, y, maxDistance);
  }

  /**
   * TH√äM M·ªöI: X·ª≠ l√Ω b·ªè n·∫Øm khi player ch·∫øt
   */
  public handlePlayerDeath(): void {
    if (this.room && this.player) {
      // G·ª≠i message ƒë·ªÉ server bi·∫øt player n√†y ch·∫øt v√† c·∫ßn b·ªè t·∫•t c·∫£ grab
      this.room.send("playerDied");
    }
  }

  // ===============================================
  // === TH√äM M·ªöI C√ÅC PH∆Ø∆†NG TH·ª®C CHECKPOINT/RESPAWN ===
  // ===============================================

  /**
   * üö© SET CHECKPOINT - ƒê∆∞·ª£c g·ªçi b·ªüi Rules khi ng∆∞·ªùi ch∆°i ch·∫°m v√†o checkpoint
   * @param position V·ªã tr√≠ c·ªßa checkpoint m·ªõi
   * @returns {boolean} Tr·∫£ v·ªÅ true n·∫øu checkpoint ƒë∆∞·ª£c c·∫≠p nh·∫≠t, false n·∫øu n√≥ ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t r·ªìi.
   */
  public setCheckpoint(position: { x: number; y: number }): boolean {
    // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu ƒë√¢y l√† m·ªôt checkpoint m·ªõi
    if (
      this.lastCheckpoint?.x !== position.x ||
      this.lastCheckpoint?.y !== position.y
    ) {
      this.lastCheckpoint = position;
      console.log(`üö© New checkpoint set at:`, position);

      // Hi·ªáu ·ª©ng nh·ªè ƒë·ªÉ b√°o cho ng∆∞·ªùi ch∆°i
      this.cameraManager.flash(0xffff00, 200);
      return true;
    }
    return false; // Checkpoint n√†y ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t tr∆∞·ªõc ƒë√≥
  }

  /**
   * üíÄ HANDLE PLAYER FALL - ƒê∆∞·ª£c g·ªçi b·ªüi Player khi n√≥ r∆°i ra kh·ªèi map
   */
  public async handlePlayerFall(): Promise<void> {
    if (this.isRespawning) return; // N·∫øu ƒëang trong qu√° tr√¨nh respawn th√¨ b·ªè qua

    this.isRespawning = true;
    console.log("üíÄ Handling player fall...");

    // 1. Ch∆°i √¢m thanh th·∫•t b·∫°i (n·∫øu c√≥)
    // this.sound.play("fall_sfx");

    // 2. L√†m m·ªù m√†n h√¨nh
    await this.cameraManager.fade(0x000000, 300);

    // 3. X√°c ƒë·ªãnh v·ªã tr√≠ h·ªìi sinh
    // N·∫øu c√≥ checkpoint th√¨ d√πng checkpoint, kh√¥ng th√¨ d√πng player_start
    const respawnPosition = this.lastCheckpoint || this.spawnPoint;

    if (this.lastCheckpoint) {
      console.log(
        `üíÄ Respawning at last checkpoint: (${respawnPosition.x}, ${respawnPosition.y})`
      );
    } else {
      console.log(
        `üíÄ No checkpoint found, respawning at player_start: (${respawnPosition.x}, ${respawnPosition.y})`
      );
    }

    // 4. G·ªçi chuy√™n gia ƒë·ªÉ th·ª±c hi·ªán h·ªìi sinh
    this.playerHandler.respawnPlayer(this.player, respawnPosition);

    // 5. L√†m s√°ng m√†n h√¨nh tr·ªü l·∫°i
    await this.cameraManager.fadeIn(300);

    // 6. Reset c·ªù
    this.isRespawning = false;
  }

  /**
   * TH√äM M·ªöI: HANDLE PLAYER DEATH BY HAZARD - ƒê∆∞·ª£c g·ªçi khi ng∆∞·ªùi ch∆°i ch·∫øt do va ch·∫°m v·∫≠t nguy hi·ªÉm
   */
  public async handlePlayerDeathByHazard(
    hazardTile: Phaser.Tilemaps.Tile
  ): Promise<void> {
    if (this.isRespawning) return; // N·∫øu ƒëang trong qu√° tr√¨nh respawn th√¨ b·ªè qua

    this.isRespawning = true;
    console.log("üíÄ Handling player death by hazard...");

    // 1. ·ª¶y quy·ªÅn cho Rules x·ª≠ l√Ω h√¨nh ph·∫°t (tr·ª´ ƒëi·ªÉm, v.v.)
    this.rules.handleHazardCollision(hazardTile, this);

    // 2. G·ª≠i th√¥ng b√°o l√™n server ƒë·ªÉ x·ª≠ l√Ω logic multiplayer (v√≠ d·ª•: b·ªè n·∫Øm)
    // T√°i s·ª≠ d·ª•ng l·∫°i ph∆∞∆°ng th·ª©c ƒë√£ c√≥!
    this.handlePlayerDeath();

    // 3. L√†m m·ªù m√†n h√¨nh
    await this.cameraManager.fade(0x000000, 300);

    // 4. X√°c ƒë·ªãnh v·ªã tr√≠ h·ªìi sinh
    const respawnPosition = this.lastCheckpoint || this.spawnPoint;

    if (this.lastCheckpoint) {
      console.log(
        `üíÄ Respawning at last checkpoint: (${respawnPosition.x}, ${respawnPosition.y})`
      );
    } else {
      console.log(
        `üíÄ No checkpoint found, respawning at player_start: (${respawnPosition.x}, ${respawnPosition.y})`
      );
    }

    // 5. G·ªçi chuy√™n gia ƒë·ªÉ th·ª±c hi·ªán h·ªìi sinh
    this.playerHandler.respawnPlayer(this.player, respawnPosition);

    // 6. L√†m s√°ng m√†n h√¨nh tr·ªü l·∫°i
    await this.cameraManager.fadeIn(300);

    // 7. Reset c·ªù
    this.isRespawning = false;
  }

  /**
   * TH√äM M·ªöI: API ƒë·ªÉ WorldBuilder c√≥ th·ªÉ th√™m c√°c sprite v√†o map
   */
  public addInteractiveTileSprite(
    id: string,
    sprite: Phaser.GameObjects.Sprite
  ): void {
    this.interactiveTileSprites.set(id, sprite);
  }

  /**
   * C·∫¨P NH·∫¨T HO√ÄN TO√ÄN: X·ª≠ l√Ω va ch·∫°m l√≤ xo m·ªôt c√°ch th√¥ng minh, h·ªó tr·ª£ nhi·ªÅu h∆∞·ªõng.
   * - X√°c ƒë·ªãnh h∆∞·ªõng c·ªßa l√≤ xo (ƒë·ª©ng, ngang).
   * - Ki·ªÉm tra h∆∞·ªõng ng∆∞·ªùi ch∆°i va ch·∫°m v√†o l√≤ xo.
   * - √Åp d·ª•ng l·ª±c ƒë·∫©y ƒë√∫ng h∆∞·ªõng (l√™n, tr√°i, ph·∫£i).
   */
  // Spring handling moved to SpringBehavior

  // === LOGIC ƒê·ªíNG B·ªò H√ìA L√í XO ===

  /**
   * TH√äM M·ªöI: G·ª≠i th√¥ng tin c√°c l√≤ xo l√™n server.
   */
  private registerSpringsWithServer(): void {
    if (!this.room || this.hasRegisteredSprings) return;

    if (this.springsData.length > 0) {
      this.room.send("registerSprings", this.springsData);
      this.hasRegisteredSprings = true;
      console.log(
        `[Client] Registered ${this.springsData.length} springs with server.`
      );
    }
  }

  /**
   * TH√äM M·ªöI: L·∫Øng nghe v√† ph·∫£n h·ªìi c√°c thay ƒë·ªïi tr·∫°ng th√°i l√≤ xo t·ª´ server.
   */
  private listenToSpringChanges(): void {
    if (!this.room) return;
    // S·ª¨A L·∫†I LOG B√äN D∆Ø·ªöI CHO ƒê√öNG
    console.log("[Client] Setting up spring change listeners...");

    this.room.onStateChange((state: any) => {
      if (state.springs) {
        state.springs.forEach((spring: any, springId: string) => {
          const currentState = spring.state;
          const lastKnownState = this.lastSpringStates.get(springId);

          if (lastKnownState !== currentState) {
            this.updateSpringVisuals(springId, currentState);
            this.lastSpringStates.set(springId, currentState);
          }
        });
      }
    });
  }

  /**
   * TH√äM M·ªöI: H√†m trung t√¢m ƒë·ªÉ c·∫≠p nh·∫≠t h√¨nh ·∫£nh c·ªßa l√≤ xo.
   */
  private updateSpringVisuals(springId: string, state: string): void {
    const springSprite = this.interactiveTileSprites.get(springId);
    if (!springSprite) return;

    // S·ª¨A D√íNG N√ÄY: L·∫•y animKey t·ª´ data ƒë√£ l∆∞u
    const animKey = springSprite.getData("animKey");
    if (!animKey) return;

    const animData = this.anims.get(animKey);
    if (!animData || animData.frames.length < 2) return;

    if (state === "extended") {
      // ƒê·∫∑t frame l√† frame th·ª© 2 (bung ra)
      springSprite.setFrame(animData.frames[1].frame.name);
    } else {
      // state === 'idle'
      // ƒê·∫∑t frame l√† frame ƒë·∫ßu ti√™n (n√©n l·∫°i)
      springSprite.setFrame(animData.frames[0].frame.name);
    }
  }
}
