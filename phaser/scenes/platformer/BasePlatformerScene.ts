import { BaseGameScene } from "../BaseGameScene";
import { EventBus } from "../../EventBus";
import {
  Player,
  InputManager,
  CameraManager,
  TimerManager,
  MinigameCore,
  CHARACTERS,
  NetworkManager,
  AnimationManager,
  AnimationState,
} from "../../classes";
import { CAMERA_CONFIG, TIMER_CONFIG } from "../../config/constants";
import { PlatformerLogicCore } from "./PlatformerLogicCore";
import { PlatformerWorldBuilder } from "./PlatformerWorldBuilder";
import { PlatformerPlayerHandler } from "./PlatformerPlayerHandler";
import { PlatformerNetworkHandler } from "../../classes/platformer/PlatformerNetworkHandler";
import { IPlatformerRules } from "./rules/IPlatformerRules";
import { Room, getStateCallbacks } from "colyseus.js";
import {
  GameRoomState,
  Player as PlayerStateSchema,
} from "../../classes/core/types/GameRoomState";

/**
 * üéÆ BASE PLATFORMER SCENE - C·∫•p 2: L·ªõp c∆° s·ªü cho d·∫°ng ch∆°i Platformer
 *
 * KI·∫æN TR√öC M·ªöI v·ªõi STRATEGY PATTERN:
 * - Kh√¥ng c√≤n ch·ª©a logic nghi·ªáp v·ª• trong c√°c hook methods
 * - Bu·ªôc subclass ph·∫£i ch·ªçn m·ªôt "b·ªô quy t·∫Øc" (IPlatformerRules)
 * - T√°ch bi·ªát ho√†n to√†n "khung platformer" v√† "lu·∫≠t ch∆°i"
 *
 * TR√ÅCH NHI·ªÜM:
 * - T·∫°o Player v·ªõi v·∫≠t l√Ω platformer
 * - Kh·ªüi t·∫°o InputManager, CameraManager (common cho t·∫•t c·∫£ platformer)
 * - X·ª≠ l√Ω logic chung: t·∫°o map t·ª´ Tiled, setup collision v·ªõi Platforms
 * - Qu·∫£n l√Ω TimerManager cho gameplay
 * - ·ª¶y quy·ªÅn logic nghi·ªáp v·ª• cho IPlatformerRules
 *
 * KI·∫æN TR√öC:
 * - Template Method pattern: Cung c·∫•p skeleton cho platformer
 * - Strategy Pattern: S·ª≠ d·ª•ng IPlatformerRules cho logic nghi·ªáp v·ª•
 * - Composition: S·ª≠ d·ª•ng PlatformerLogicCore v·ªõi rules
 * - Abstract: Subclass ph·∫£i cung c·∫•p config c·ª• th·ªÉ V√Ä rules
 */
export abstract class BasePlatformerScene extends BaseGameScene {
  // === SCENE CONFIGURATION - Subclass ph·∫£i override ===
  protected abstract readonly TILEMAP_KEY: string; // Key c·ªßa tilemap JSON
  protected abstract readonly TILEMAP_PATH: string; // ƒê∆∞·ªùng d·∫´n file JSON
  protected abstract readonly SCENE_NAME: string; // T√™n hi·ªÉn th·ªã scene

  // === STRATEGY PATTERN - Subclass ph·∫£i implement ===
  /**
   * Ph∆∞∆°ng th·ª©c tr·ª´u t∆∞·ª£ng bu·ªôc scene con ph·∫£i "ch·ªçn" m·ªôt b·ªô lu·∫≠t ch∆°i.
   * ƒê√¢y l√† c·ªët l√µi c·ªßa Strategy Pattern.
   * @returns M·ªôt instance c·ªßa l·ªõp implement IPlatformerRules.
   */
  protected abstract createRules(): IPlatformerRules;

  // === COMPONENTS ===
  protected tilemap!: Phaser.Tilemaps.Tilemap; // B·∫£n ƒë·ªì game t·ª´ Tiled
  protected platformsLayer!: Phaser.Tilemaps.TilemapLayer; // Layer ch·ª©a platforms v√† xu

  // === GAME OBJECTS ===
  protected player!: Player; // Nh√¢n v·∫≠t ch√≠nh

  // === MANAGERS ===
  protected inputManager!: InputManager; // Qu·∫£n l√Ω input keyboard
  protected cameraManager!: CameraManager; // Qu·∫£n l√Ω camera effects
  protected timerManager!: TimerManager; // Qu·∫£n l√Ω th·ªùi gian game

  // === MULTIPLAYER ===
  protected networkManager!: NetworkManager; // Qu·∫£n l√Ω k·∫øt n·ªëi m·∫°ng
  protected room?: Room<GameRoomState>; // Ph√≤ng game Colyseus

  // Thay th·∫ø c√°c thu·ªôc t√≠nh multiplayer c≈© b·∫±ng m·ªôt chuy√™n gia duy nh·∫•t
  protected networkHandler!: PlatformerNetworkHandler;

  // TH√äM M·ªöI: M·ªôt thu·ªôc t√≠nh ƒë·ªÉ l∆∞u tr·ªØ h√†m x·ª≠ l√Ω s·ª± ki·ªán
  private networkConnectedHandler!: (room: Room<GameRoomState>) => void;

  // === STRATEGY PATTERN COMPONENTS ===
  protected rules!: IPlatformerRules; // B·ªô quy t·∫Øc do subclass ch·ªçn
  protected logicCore!: PlatformerLogicCore; // Core logic v·ªõi rules
  protected minigameCore!: MinigameCore; // MinigameCore ƒë·ªÉ x·ª≠ l√Ω ƒëi·ªÉm v√† quiz

  // === CHUY√äN GIA HELPER ===
  private worldBuilder!: PlatformerWorldBuilder; // Chuy√™n gia x√¢y d·ª±ng th·∫ø gi·ªõi
  private playerHandler!: PlatformerPlayerHandler; // Chuy√™n gia v·ªÅ ng∆∞·ªùi ch∆°i

  /**
   * üé¨ PRELOAD - Load assets chung v√† ri√™ng cho platformer
   *
   * LU·ªíNG:
   * 1. Emit loading events cho React
   * 2. Load common platformer assets
   * 3. G·ªçi loadSceneSpecificAssets() ƒë·ªÉ subclass load ri√™ng
   * 4. Setup progress tracking
   */
  preload(): void {
    console.log(`üì¶ ${this.SCENE_NAME}: Loading assets...`);

    // Emit loading start event
    EventBus.emit("scene-loading-start", { sceneName: this.SCENE_NAME });

    // Setup progress tracking
    this.setupProgressTracking();

    // Load common platformer assets
    this.loadCommonAssets();

    // Load scene-specific assets (subclass implement)
    this.loadSceneSpecificAssets();
  }

  /**
   * üìä SETUP PROGRESS TRACKING - Setup loading progress events
   */
  private setupProgressTracking(): void {
    this.load.on("progress", (progress: number) => {
      EventBus.emit("scene-loading-progress", {
        progress: progress,
        sceneName: this.SCENE_NAME,
      });
    });

    this.load.on("complete", () => {
      EventBus.emit("scene-loading-complete", { sceneName: this.SCENE_NAME });
    });
  }

  /**
   * üì¶ LOAD COMMON ASSETS - Load assets chung cho t·∫•t c·∫£ platformer
   */
  private loadCommonAssets(): void {
    // Load tilemap JSON c·ªßa scene c·ª• th·ªÉ
    this.load.tilemapTiledJSON(this.TILEMAP_KEY, this.TILEMAP_PATH);

    // Load common tilesets (d√πng chung cho t·∫•t c·∫£ platformer)
    this.load.image(
      "spritesheet-tiles-default",
      "/kenney_new-platformer-pack-1.0/Spritesheets/spritesheet-tiles-default_extruded.png"
    );
    this.load.image(
      "spritesheet-backgrounds-default",
      "/kenney_new-platformer-pack-1.0/Spritesheets/spritesheet-backgrounds-default_extruded.png"
    );

    // Load character spritesheet (d√πng chung)
    this.load.image(
      "spritesheet-characters-default",
      "/kenney_new-platformer-pack-1.0/Spritesheets/spritesheet-characters-default.png"
    );

    // Load common sound effects
    this.load.audio(
      "coin",
      "/kenney_new-platformer-pack-1.0/Sounds/sfx_coin.ogg"
    );
    this.load.audio(
      "jump",
      "/kenney_new-platformer-pack-1.0/Sounds/sfx_jump.ogg"
    );
  }

  /**
   * üì¶ LOAD SCENE SPECIFIC ASSETS - Abstract method cho subclass
   * Subclass override ƒë·ªÉ load assets ri√™ng cho scene ƒë√≥
   */
  protected abstract loadSceneSpecificAssets(): void;

  /**
   * üé¨ INITIALIZE SCENE - Implementation c·ªßa abstract method t·ª´ BaseGameScene
   *
   * LU·ªíNG M·ªöI v·ªõi STRATEGY PATTERN v√† NETWORK HANDLER:
   * 1. T·∫°o b·ªô quy t·∫Øc do scene con quy·∫øt ƒë·ªãnh (Strategy Pattern)
   * 2. Kh·ªüi t·∫°o c√°c chuy√™n gia Helper
   * 3. Kh·ªüi t·∫°o b·ªô quy t·∫Øc v·ªõi c√°c tham chi·∫øu c·∫ßn thi·∫øt
   * 4. D√πng WorldBuilder ƒë·ªÉ x√¢y d·ª±ng th·∫ø gi·ªõi
   * 5. Setup c√°c managers (Input, Camera, Timer)
   * 6. Kh·ªüi t·∫°o Network Handler
   * 7. LogicCore nh·∫≠n v√†o b·ªô quy t·∫Øc thay v√¨ scene
   * 8. Reset MinigameCore
   */
  protected initializeScene(): void {
    console.log(
      `üöÄ ${this.SCENE_NAME}: Orchestrating scene setup with Strategy Pattern...`
    );

    // 0. QUAN TR·ªåNG: Reset player ƒë·ªÉ tr√°nh conflict gi·ªØa c√°c round
    this.player = null as any;
    console.log(`üîÑ ${this.SCENE_NAME}: Player reset for new round`);

    // 1. T·∫°o b·ªô quy t·∫Øc do scene con quy·∫øt ƒë·ªãnh (Strategy Pattern)
    this.rules = this.createRules();
    console.log(`üéØ ${this.SCENE_NAME}: Rules created`);

    // 2. Kh·ªüi t·∫°o c√°c chuy√™n gia Helper v√† cores
    this.worldBuilder = new PlatformerWorldBuilder(this, this.TILEMAP_KEY);
    this.playerHandler = new PlatformerPlayerHandler(this);
    this.minigameCore = MinigameCore.getInstance();

    // 3. Kh·ªüi t·∫°o b·ªô quy t·∫Øc v·ªõi c√°c tham chi·∫øu c·∫ßn thi·∫øt
    this.rules.initialize(this, this.minigameCore);
    console.log(`üéØ ${this.SCENE_NAME}: Rules initialized`);

    // 4. LogicCore gi·ªù ch·ªâ nh·∫≠n b·ªô quy t·∫Øc - kh√¥ng c√≥ scene dependency
    this.logicCore = new PlatformerLogicCore(this.rules);
    console.log(
      `üéÆ ${this.SCENE_NAME}: Pure LogicCore created with rules only`
    );

    // 5. D√πng chuy√™n gia ƒë·ªÉ x√¢y d·ª±ng th·∫ø gi·ªõi
    const { platformsLayer } = this.worldBuilder.build();
    this.platformsLayer = platformsLayer;

    // 6. Setup c√°c managers (logic n√†y v·∫´n gi·ªØ l·∫°i v√¨ kh√° ƒë∆°n gi·∫£n)
    this.setupPlatformerManagers();

    // 7. Kh·ªüi t·∫°o chuy√™n gia m·∫°ng
    this.networkHandler = new PlatformerNetworkHandler(
      this,
      this.platformsLayer
    );

    // 8. L·∫§Y INSTANCE NetworkManager, KH√îNG K·∫æT N·ªêI
    this.networkManager = NetworkManager.getInstance();

    // X√ìA D√íNG N√ÄY: this.networkManager.joinGameRoom();
    // RoundManager s·∫Ω x·ª≠ l√Ω vi·ªác join room khi b·∫Øt ƒë·∫ßu v√≤ng.

    // 9. THAY ƒê·ªîI C√ÅCH ƒêƒÇNG K√ù LISTENER
    // X√≥a listener c≈© ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng b·ªã tr√πng l·∫∑p t·ª´ scene tr∆∞·ªõc
    if (this.networkConnectedHandler) {
      EventBus.off("network-connected", this.networkConnectedHandler);
    }

    // ƒê·ªãnh nghƒ©a h√†m x·ª≠ l√Ω v√† g√°n v√†o thu·ªôc t√≠nh v·ª´a t·∫°o
    this.networkConnectedHandler = (room: Room<GameRoomState>) => {
      // Ki·ªÉm tra scene ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ho√†n to√†n ch∆∞a
      if (!this.networkHandler || !this.playerHandler || !this.platformsLayer) {
        console.log(
          `üåê ${this.scene.key} received network-connected but scene not fully initialized. Ignoring.`
        );
        return;
      }

      // Ki·ªÉm tra scene c√≥ ƒëang visible kh√¥ng (b·ªè check isActive v√¨ n√≥ c√≥ th·ªÉ t·∫°m th·ªùi false)
      if (!this.scene.isVisible()) {
        console.log(
          `üåê ${
            this.scene.key
          } received network-connected but scene not visible. Visible: ${this.scene.isVisible()}. Ignoring.`
        );
        return;
      }

      console.log(
        `üåê network-connected event received in scene: ${this.scene.key}`
      );
      console.log(`üåê Room details:`, room.name, room.sessionId);
      this.room = room;
      this.networkHandler.initialize(room);
    };

    // ƒêƒÉng k√Ω listener b·∫±ng thu·ªôc t√≠nh ƒë√≥
    EventBus.on("network-connected", this.networkConnectedHandler);

    // 10. Reset game core
    this.minigameCore.resetForNewRound();

    // TH√äM M·ªöI: Ch·ªß ƒë·ªông emit tr·∫°ng th√°i ƒëi·ªÉm s·ªë ban ƒë·∫ßu
    // Sau khi resetForNewRound, ƒëi·ªÉm s·ªë ƒë∆∞·ª£c gi·ªØ l·∫°i t·ª´ c√°c v√≤ng tr∆∞·ªõc.
    // Ch√∫ng ta c·∫ßn th√¥ng b√°o cho UI bi·∫øt gi√° tr·ªã n√†y.
    EventBus.emit("minigame-score-updated", {
      oldScore: this.minigameCore.getCurrentScore(),
      newScore: this.minigameCore.getCurrentScore(),
      change: 0,
    });

    console.log(
      `‚úÖ ${this.SCENE_NAME} initialization completed. Waiting for RoundManager to join room.`
    );

    // Emit event ƒë·ªÉ NetworkManager bi·∫øt Scene ƒë√£ s·∫µn s√†ng
    EventBus.emit("scene-ready-for-network", this.SCENE_NAME);

    // Th√¥ng b√°o cho React component r·∫±ng scene ƒë√£ s·∫µn s√†ng (failsafe cho loading overlay)
    this.notifySceneReady();
  }

  /**
   * ‚öôÔ∏è SETUP PLATFORMER MANAGERS - Kh·ªüi t·∫°o managers chung cho platformer
   */
  private setupPlatformerManagers(): void {
    // Input Manager - x·ª≠ l√Ω input PC (Arrow keys, WASD, Space)
    this.inputManager = new InputManager(this);

    // Camera Manager - follow player v·ªõi config chu·∫©n
    const worldDimensions = this.worldBuilder.getWorldDimensions();
    this.cameraManager = new CameraManager(this, {
      followOffset: CAMERA_CONFIG.DEFAULT_OFFSET,
      lerpSpeed: CAMERA_CONFIG.LERP_SPEED,
      bounds: {
        x: 0,
        y: 0,
        width: worldDimensions.width,
        height: worldDimensions.height,
      },
    });

    // Timer Manager
    this.timerManager = new TimerManager(this);
    this.startPlatformerGameTimer();

    console.log("‚öôÔ∏è Platformer managers initialized");
  }

  /**
   * ‚è∞ START PLATFORMER GAME TIMER - B·∫Øt ƒë·∫ßu timer chung cho platformer
   */
  private startPlatformerGameTimer(): void {
    const gameTimeLimit =
      this.getRoundData()?.gameTimeLimit || TIMER_CONFIG.GAME_TIME_LIMIT;

    this.timerManager.startTimer({
      duration: gameTimeLimit,
      onTimeUp: () => {
        console.log(`‚è∞ ${this.SCENE_NAME} time up! Auto triggering quiz...`);
      },
      onWarning: (timeLeft: number) => {
        console.log(
          `‚ö†Ô∏è ${this.SCENE_NAME} time warning: ${this.timerManager.formatTime(
            timeLeft
          )} left`
        );
      },
      onTick: (timeLeft: number) => {
        EventBus.emit("game-timer-update", {
          timeLeft,
          formatted: this.timerManager.formatTime(timeLeft),
          isWarning: this.timerManager.isInWarningTime(),
        });
      },
    });

    // TH√äM M·ªöI: Ch·ªß ƒë·ªông emit tr·∫°ng th√°i timer ban ƒë·∫ßu
    // Ngay sau khi timer b·∫Øt ƒë·∫ßu, h√£y g·ª≠i tr·∫°ng th√°i ƒë·∫ßu ti√™n cho UI.
    EventBus.emit("game-timer-update", {
      timeLeft: gameTimeLimit,
      formatted: this.timerManager.formatTime(gameTimeLimit),
      isWarning: false,
    });
  }

  // === MULTIPLAYER METHODS ===

  /**
   * üéØ CREATE MAIN PLAYER - ƒê∆∞·ª£c g·ªçi b·ªüi NetworkHandler ƒë·ªÉ t·∫°o ng∆∞·ªùi ch∆°i ch√≠nh
   * @param playerState Tr·∫°ng th√°i ban ƒë·∫ßu t·ª´ server
   */
  public createMainPlayer(playerState: PlayerStateSchema): void {
    console.log(`üéØ createMainPlayer called with state:`, {
      x: playerState.x,
      y: playerState.y,
    });

    console.log(
      `üéÆ Creating main player at position: ${playerState.x}, ${playerState.y}`
    );

    // üîß Null checks tr∆∞·ªõc khi t·∫°o player
    if (!this.playerHandler) {
      console.error(`‚ùå PlayerHandler is null in ${this.scene.key}`);
      return;
    }
    if (!this.platformsLayer) {
      console.error(`‚ùå PlatformsLayer is null in ${this.scene.key}`);
      return;
    }
    if (!this.inputManager) {
      console.error(`‚ùå InputManager is null in ${this.scene.key}`);
      return;
    }

    console.log(`üîß Creating player with playerHandler:`, !!this.playerHandler);

    this.player = this.playerHandler.spawnPlayer(
      { x: playerState.x, y: playerState.y },
      this.platformsLayer,
      this.inputManager,
      this.cameraManager,
      this.logicCore,
      this.networkManager
    );

    // Setup interactive objects CH·ªà SAU KHI player ch√≠nh ƒë∆∞·ª£c t·∫°o
    this.worldBuilder.setupInteractiveObjects(
      this.player.getSprite(),
      this.logicCore
    );

    console.log(
      `‚úÖ Main player created successfully at position: ${playerState.x}, ${playerState.y}`
    );
  }

  // === UPDATE LOOP ===

  /**
   * ÔøΩ UPDATE - Game loop c·ª±c k·ª≥ g·ªçn g√†ng v·ªõi Network Handler
   */
  update(): void {
    // Ch·ªâ c·∫ßn ra l·ªánh cho c√°c th√†nh ph·∫ßn t·ª± c·∫≠p nh·∫≠t
    this.player?.update();
    this.networkHandler?.update();
  }

  // === PUBLIC API - Cho React components ===

  /**
   * üìç GET PLAYER POSITION - API cho React
   */
  public getPlayerPosition() {
    return this.player ? this.player.getPosition() : null;
  }

  /**
   * ‚è∏Ô∏è PAUSE GAME TIMER - API cho React
   */
  public pauseGameTimer(): void {
    this.timerManager.pauseTimer();
  }

  /**
   * ‚ñ∂Ô∏è RESUME GAME TIMER - API cho React
   */
  public resumeGameTimer(): void {
    this.timerManager.resumeTimer();
  }

  /**
   * üó∫Ô∏è GET TILEMAP - API ƒë·ªÉ truy c·∫≠p tilemap th√¥ng qua WorldBuilder
   */
  public getTilemap(): Phaser.Tilemaps.Tilemap {
    return this.worldBuilder.getTilemap();
  }

  /**
   * üìê GET WORLD DIMENSIONS - API ƒë·ªÉ l·∫•y k√≠ch th∆∞·ªõc th·∫ø gi·ªõi
   */
  public getWorldDimensions(): { width: number; height: number } {
    return this.worldBuilder.getWorldDimensions();
  }

  // === CONFIGURATION HOOKS - Subclass c√≥ th·ªÉ override ===

  /**
   * üë§ GET CHARACTER DATA - Hook ƒë·ªÉ subclass ch·ªçn character
   * Default: ORANGE character
   */
  public getCharacterData() {
    return CHARACTERS.ORANGE;
  }

  /**
   * ‚ö° GET PLAYER PHYSICS CONFIG - Hook ƒë·ªÉ subclass custom physics
   * Default: Standard platformer physics
   */
  public getPlayerPhysicsConfig() {
    return {
      speed: 200,
      jumpPower: 700,
      gravity: 800,
      bounce: 0.2,
    };
  }

  // === CLEANUP ===

  /**
   * üóëÔ∏è CLEANUP ON SHUTDOWN - Override t·ª´ BaseGameScene
   */
  protected cleanupOnShutdown(): void {
    console.log(`üóëÔ∏è ${this.SCENE_NAME}: Starting cleanup...`);

    super.cleanupOnShutdown();

    // G·ª† B·ªé LISTENER KHI SCENE B·ªä H·ª¶Y
    // ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng nh·∫•t ƒë·ªÉ s·ª≠a l·ªói
    if (this.networkConnectedHandler) {
      EventBus.off("network-connected", this.networkConnectedHandler);
      console.log(`üóëÔ∏è ${this.SCENE_NAME}: Removed network-connected listener.`);
      this.networkConnectedHandler = null as any;
    }

    // Ra l·ªánh cho c√°c chuy√™n gia t·ª± d·ªçn d·∫πp
    this.networkHandler?.cleanup();
    this.networkManager?.leaveCurrentRoom();

    // QUAN TR·ªåNG: Cleanup player tr∆∞·ªõc khi chuy·ªÉn scene
    if (this.player) {
      console.log(`üóëÔ∏è ${this.SCENE_NAME}: Cleaning up player`);
      this.player.destroy();
      this.player = null as any;
    }

    // Cleanup b·ªô quy t·∫Øc TR∆Ø·ªöC khi cleanup c√°c component kh√°c
    this.rules?.cleanup();

    // Cleanup platformer-specific resources
    this.timerManager?.destroy();
    this.logicCore?.cleanup();

    // Cleanup network handler ƒë·ªÉ tr√°nh duplicate events
    this.networkHandler?.cleanup();

    // Cleanup c√°c chuy√™n gia helpers
    this.worldBuilder?.cleanup();
    this.playerHandler?.cleanup();

    console.log(`üóëÔ∏è ${this.SCENE_NAME} platformer cleanup completed.`);
  }

  /**
   * ‚è∏Ô∏è ON PAUSE - Override t·ª´ BaseGameScene
   */
  protected onPause(): void {
    super.onPause();
    this.pauseGameTimer();
  }

  /**
   * ‚ñ∂Ô∏è ON RESUME - Override t·ª´ BaseGameScene
   */
  protected onResume(): void {
    super.onResume();
    this.resumeGameTimer();
  }
}
